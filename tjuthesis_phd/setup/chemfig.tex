% !TeX encoding = ISO-8859-1
% Ce fichier contient le code de l'extension "chemfig"
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%                                                                    %
\def\CFname                    {chemfig}                             %
\def\CFver                       {1.33}                              %
%                                                                    %
\def\CFdate                   {2018/10/31}                           %
%                                                                    %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
%____________________________________________________________________
% Author     : Christian Tellechea                                   |
% Status     : Maintained                                            |
% Email      : unbonpetit@netc.fr                                    |
% Package URL: https://www.ctan.org/pkg/chemfig                      |
% Bug tracker: https://framagit.org/unbonpetit/chemfig/issues        |
% Repository : https://framagit.org/unbonpetit/chemfig/tree/master   |
% Copyright  : Christian Tellechea 2010-2018                         |
% Licence    : Released under the LaTeX Project Public License v1.3c |
%              or later, see http://www.latex-project.org/lppl.txt   |
% Files      : 1) chemfig.tex                                        |
%              2) chemfig.sty                                        |
%              3) t-chemfig.tex                                      |
%              4) README                                             |
%              5) chemfig_doc_fr.tex                                 |
%              6) chemfig_doc_fr.pdf                                 |
%              7) chemfig_doc_en.tex                                 |
%              8) chemfig_doc_fr.pdf                                 |
%--------------------------------------------------------------------

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%                       P R É A L A B L E                        %%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%-------------------------- Annonce package --------------------------
\ifdefined\ProvidesPackage\else
	\immediate\write -1 {%
	Package: \CFname\space\CFdate\space\space v\CFver\space\space
	Draw molecule with an easy syntax (CT)}%
\fi
%------------------------- Vérification etex -------------------------
\begingroup
	\edef\CFtempa{\meaning\eTeXversion}
	\edef\CFtempb{\string\eTeXversion}
	\let\CFtemp\endgroup
	\unless\ifx\CFtempa\CFtempb
		\errmessage{Package \CFname\space Error: you are not using an eTeX engine, chemfig cannot work.}%
		\def\CFtemp{\endgroup\endinput}%
	\fi
\CFtemp

%------------------------ Chargement simplekv ------------------------
\unless\ifdefined\skvname
	\begingroup\def\CFtemp{\endgroup\input simplekv.tex\relax}%
	\expandafter\CFtemp
\fi

%-------------------------- Chargement tikz --------------------------
\unless\ifdefined\tikzpicture
	\begingroup\def\CFtemp{\endgroup\input tikz.tex\relax}%
	\expandafter\CFtemp
\fi
\usetikzlibrary{arrows.meta}

%-------------------------- Régime catcodes --------------------------
\begingroup
	\def\X#1{\catcode\number`#1=\number\catcode`#1\relax}
	\xdef\CFrestorecatcode{\X\[\X\]\X\:\X\(\X\)\X\,\X\-\X\=\X\~\X\!\X\?\X\<\X\>\X\;\X\*\X\|\X\@\X\ }%
\endgroup
\catcode`\[12 \catcode`\]12 \catcode`\:12 \catcode`\(12
\catcode`\)12 \catcode`\,12 \catcode`\-12 \catcode`\=12
\catcode`\~12 \catcode`\!12 \catcode`\?12 \catcode`\<12
\catcode`\>12 \catcode`\;12 \catcode`\*12 \catcode`\|12
\catcode`\@11 \catcode`\#6  \catcode`\ 10

%--------------------------- Allocations -----------------------------
\newcount\CF@cnt@atomingroup
\newcount\CF@cnt@groupnumber
\newcount\CF@cnt@atomnumber
\newcount\CF@cnt@cycle
\newcount\CF@compound@cnt

\newif\ifCF@incycle
\newif\ifCF@cyclearc
\newif\ifCF@definesubmol
\newif\ifCF@name@dp@adjust
\newif\ifCF@macrofixedbondlength
\newif\ifCF@name@start
\newif\ifCF@name@end

\newdimen\CF@dim
\newdimen\CF@arrow@size

\newbox\CF@lewis@box
\newbox\CF@box@boxa
\newbox\CF@stuff@box

%-------------------------- Petites macros ---------------------------
\def\CF@quark{\CF@quark}
\long\def\CF@execfirst#1#2{#1}
\long\def\CF@execsecond#1#2{#2}
\long\def\CF@id#1{#1}
\long\def\CF@gobarg#1{}
\long\def\CF@gobtwoargs#1#2{}
\def\CF@firsttonil#1#2\@nil{#1}
\def\CF@sanitize@lastitem#1,\empty#2\@nil{#1}
\def\CF@gobtikzinstruction#1;{}
\def\CF@makeother#1{\catcode`#1=12\relax}
\def\CF@lettoken#1#2{\let#1= #2}\CF@lettoken\CF@sptoken{ }
\def\CF@ifx#1#2{\ifx#1#2\expandafter\CF@execfirst\else\expandafter\CF@execsecond\fi}
\def\CF@ifempty#1{\ifx\empty#1\empty\expandafter\CF@execfirst\else\expandafter\CF@execsecond\fi}
\def\CF@doifempty#1{\ifx\empty#1\empty\expandafter\CF@id\else\expandafter\CF@gobarg\fi}
\def\CF@doifnotempty#1{\ifx\empty#1\empty\expandafter\CF@gobarg\else\expandafter\CF@id\fi}
\def\CF@gobtonil#1\@nil{}
\edef\CF@hash{\string#}
\edef\CF@arobas{\string @}
\def\CF@three@ea{\expandafter\expandafter\expandafter}
\def\CF@exp@macroarg#1#2{\expandafter#1\expandafter{#2}}
\def\CF@eexp@macroarg#1#2{\expandafter\expandafter\expandafter#1\expandafter\expandafter\expandafter{#2}}
\def\CF@exp@twomacroargs#1#2#3{\CF@exp@second{\CF@exp@macroarg#1{#2}}{#3}}
\def\CF@exp@threemacroargs#1#2#3#4{\CF@exp@second{\CF@exp@twomacroargs#1{#2}{#3}}{#4}}
\def\CF@swap@arg#1#2{#2{#1}}
\def\CF@exp@second#1#2{\CF@exp@macroarg\CF@swap@arg{#2}{#1}}% \CF@exp@second<{arg1>}{<arg2>} donne "<arg1>{*<arg2>}"
\def\CF@eexp@second#1#2{\CF@eexp@macroarg\CF@swap@arg{#2}{#1}}% \CF@eexp@second{<arg1>}{<arg2>} donne "<arg1>{**<arg2>}"
\def\CF@swap@unarg#1#2{#2#1}
\def\CF@exp@after#1#2{\CF@exp@macroarg\CF@swap@unarg{#2}{#1}}% \CF@exp@after{<arg1>}{<arg2>} donne "<arg1>*<arg2>"
\def\CF@eexp@after#1#2{\CF@eexp@macroarg\CF@swap@unarg{#2}{#1}}% \CF@eexp@after{<arg1>}{<arg2>} donne "<arg1>**<arg2>"
\def\CF@add@tocs#1#2{\CF@exp@second{\def#1}{#1#2}}
\def\CF@eadd@tocs#1#2{\CF@exp@second{\CF@add@tocs#1}{#2}}\let\CF@expadd@tocs\CF@eadd@tocs
\def\CF@preadd@tocs#1#2{\CF@exp@second{\CF@preadd@tocs@a#1{#2}}#1}
\def\CF@preadd@tocs@a#1#2#3{\def#1{#2#3}}
\def\CF@edefadd@tocs#1#2{%
	\edef\CF@tmp@str{#2}%
	\CF@exp@second{\CF@add@tocs#1}{\CF@tmp@str}%
}
\long\def\CF@ifnextchar#1#2#3{%
	\let\CF@ifnextchar@tok=#1% <- espace indésirable, bugfix v1.31
	\def\CF@ifnextchar@codetrue{#2}%
	\def\CF@ifnextchar@codefalse{#3}%
	\futurelet\CF@temptok\CF@ifnextchar@i}
\def\CF@ifnextchar@i{%
	\CF@ifx\CF@temptok\CF@sptoken
		\CF@ifnextchar@ii
		{\CF@ifx\CF@temptok\CF@ifnextchar@tok\CF@ifnextchar@codetrue\CF@ifnextchar@codefalse}%
}
\expandafter\def\expandafter\CF@ifnextchar@ii\space{\futurelet\CF@temptok\CF@ifnextchar@i}
\def\CF@ifstar#1{\CF@ifnextchar*{\CF@execfirst{#1}}}
\long\def\CF@testopt#1#2{\CF@ifnextchar[{#1}{#1[{#2}]}}
\def\CF@error#1{\errmessage{Package \CFname\space Error: #1.}}
\def\CF@warning#1{\immediate\write-1{Package \CFname\space Warning: #1^^J}}
\def\CF@if@integer#1{%
	\begingroup
		\afterassignment\CF@after@integer
		\CF@cnt@cycle0#1\relax
}
\def\CF@after@integer#1\relax{%
	\endgroup
	\CF@ifempty{#1}%
}
\def\CF@if@firsttokmatch#1#2{% est ce que #1 et #2 commencent par les mêmes tokens ?
	\futurelet\CF@toks@a\CF@gobtonil#1\relax\@nil
	\futurelet\CF@toks@b\CF@gobtonil#2\relax\@nil
	\CF@ifx\CF@toks@a\CF@toks@b
}
\def\CF@if@firsttokin#1{% teste si le token qui commence #1 appartient aux tokens mis dans #2
	\futurelet\CF@toks@a\CF@gobtonil#1\relax\@nil
	\CF@if@firsttokin@a
}
\def\CF@if@firsttokin@a#1{%
	\CF@ifempty{#1}
		\CF@execsecond
		{\futurelet\CF@toks@b\CF@gobtonil#1\relax\@nil
		\CF@ifx\CF@toks@a\CF@toks@b
			\CF@execfirst
			{\CF@exp@macroarg\CF@if@firsttokin@a{\CF@gobarg#1}}%
		}%
}
\def\CF@if@instr#1#2{%
	\def\CF@if@instr@a##1#2##2\@nil{\ifx\empty##2\empty\expandafter\CF@execsecond\else\expandafter\CF@execfirst\fi}%
	\CF@if@instr@a#1\@@nil#2\@nil
}
\def\CF@after@space#1 #2\@nil{#2}
\def\CF@valuetomacro#1[#2]#3{% #1= macro  #2=valeur défaut  #3=clé
	\CF@eexp@second{\def#1}{\useKV[chemfig]{#3}}%
	\ifx#1\empty\def#1{#2}\fi
}

%---------------------------- Paramètres -----------------------------
\def\setchemfig{\setKV[chemfig]}
\def\resetchemfig{%
	\setKVdefault[chemfig]{%
		atom style          ={},% code tikz mis à la fin de every node/.style
		chemfig style       ={},% code tikz mis à la fin de l'arugment optionnel de \tikzpicture
		bond join           =false,
		fixed length        =false,
		cram rectangle      =false,
		cram width          =1.5ex,
		cram dash width     =1pt,
		cram dash sep       =2pt,
		atom sep            =3em,
		bond offset         =2pt,
		double bond sep     =2pt,
		angle increment     =45,
		node style          ={},
		bond style          ={},
		lewis | width       =0.3ex,
		lewis sep           =0.4ex,
		lewis length        =1.5ex,
		lewis style         ={},
		lewis dist          =0.3em,
		lewis radius        =0.15ex,% [nouveau] rayon des disques
		cycle radius coeff  =0.75,% [nouveau] coeff du rayon  du cercle dans les cycles
		stack sep           =1.5pt,
		scheme debug        =false,
		compound style      ={},
		compound sep        =5em,
		arrow offset        =4pt,
		arrow angle         =0,
		arrow coeff         =1,
		arrow style         ={},
		arrow double sep    =2pt,%  [nouveau] espacement entre les doubles fleches
		arrow double coeff  =0.6,%  [nouveau] coefficient de la petite fleche par rapport à la grande
		arrow double harpoon=true,% [nouveau] fleche double forme harpon ou pas
		arrow label sep     =3pt,
		arrow head          =-CF,% [nouveau] style de bout de fleche
		+ sep left          =0.5em,
		+ sep right         =0.5em,
		+ vshift            =0pt,
	}%
}
\resetchemfig

\def\CF@warningdeprecated#1{\CF@warning{The macro \string#1 is deprecated. Please, use \string\setchemfig}}
\def\setcrambond{%
	\CF@warningdeprecated\setcrambond
	\CF@ifstar
		{\setchemfig{cram rectangle=true }\CF@setcrambond}
		{\setchemfig{cram rectangle=false}\CF@setcrambond}%
}
\def\CF@setcrambond#1#2#3{\setchemfig{cram width=#1,cram dash width=#2,cram dash sep=#3}}
\def\setatomsep#1{%
	\CF@warningdeprecated\setatomsep
	\setchemfig{atom sep=#1}%
}
\def\setbondoffset#1{%
	\CF@warningdeprecated\setbondoffset
	\setchemfig{bond offset=#1}%
}
\def\setdoublesep#1{%
	\CF@warningdeprecated\setdoublesep
	\setchemfig{double bond sep=#1}%
}
\def\setangleincrement#1{%
	\CF@warningdeprecated\setangleincrement
	\setchemfig{angle increment=#1}%
}
\def\enablefixedbondlength{%
	\CF@warningdeprecated\enablefixedbondlength
	\setchemfig{fixed length=true}%
}
\def\disablefixedbondlength{%
	\CF@warningdeprecated\disablefixedbondlength
	\setchemfig{fixed length=false}%
}
\def\setnodestyle#1{%
	\CF@warningdeprecated\setnodestyle
	\setchemfig{node style={#1}}%
}
\def\setbondstyle#1{%
	\CF@warningdeprecated\setbondstyle
	\setchemfig{bond style={#1}}%
}
\def\setlewis{%
	\CF@warningdeprecated\setlewis
	\CF@testopt\CF@setlewis{0.3ex}%
}
\def\CF@setlewis[#1]#2#3#4{\setchemfig{lewis | width=#1,lewis sep=#2,lewis length=#3,lewis style={#4}}}
\def\setlewisdist#1{%
	\CF@warningdeprecated\setlewisdist
	\setchemfig{lewis dist=#1}%
}
\def\setstacksep#1{%
	\CF@warningdeprecated\setstacksep
	\setchemfig{stack sep=#1}%
}
\def\setcompoundstyle#1{%
	\CF@warningdeprecated\setcompoundstyle
	\setnodestyle\setchemfig{compound style={#1}}%
}
\def\CF@setdefault@a#1,#2,#3\@nil#4#5#6{%
	\setchemfig{#4=#1}%
	\CF@if@firsttokmatch\CF@quark{#2\relax}
		{\setchemfig{#5={},#6={}}}%
		{\setchemfig{#5={#2}}%
		\CF@if@firsttokmatch\CF@quark{#3\relax}
			{\setchemfig{#6={}}}%
			{\CF@setdefault@b#3\@nil{#6}}%
		}%
}
\def\CF@setdefault@b#1,\CF@quark#2\@nil#3{\setchemfig{#3={#1}}}
\def\setarrowdefault#1{%
	\CF@warningdeprecated\setarrowdefault
	\CF@setdefault@a#1,\CF@quark,\CF@quark\@nil{arrow angle}{arrow coeff}{arrow style}%
}
\def\setandsign#1{%
	\CF@warningdeprecated\setandsign
	\CF@setdefault@a#1,\CF@quark,\CF@quark\@nil{+ sep left}{+ sep right}{+ vshift}%
}
\def\setarrowoffset#1{%
	\CF@warningdeprecated\setarrowoffset
	\setchemfig{arrow offset=#1}%
}
\def\setcompoundsep#1{%
	\CF@warningdeprecated\setcompoundsep
	\setchemfig{compound sep=#1}%
}
\def\setarrowlabelsep#1{%
	\CF@warningdeprecated\setarrowlabelsep
	\setchemfig{arrow label sep=#1}%
}
\def\enablebondjoin{%
	\CF@warningdeprecated\enablebondjoin
	\setchemfig{bond join=true}%
}
\def\disablebondjoin{%
	\CF@warningdeprecated\disablebondjoin
	\setchemfig{bond join=false}%
}
\def\schemedebug#1{%
	\CF@warningdeprecated\schemedebug
	\setchemfig{scheme debug=#1}%
}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%               D E S S I N     M O L É C U L E S                %%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\def\CF@sanitize@catcode{%
	\CF@makeother\[\CF@makeother\]\CF@makeother\:\CF@makeother\(\CF@makeother\)%
	\CF@makeother\,\CF@makeother\-\CF@makeother\=\CF@makeother\~\CF@makeother\!%
	\CF@makeother\?\CF@makeother\<\CF@makeother\>\CF@makeother\;\CF@makeother\*%
	\CF@makeother\|\CF@makeother\#\CF@makeother\@%
}

\def\CF@node@content{\expandafter\printatom\expandafter{\csname atom@\number\CF@cnt@atomnumber\endcsname\CF@node@strut}}

\def\chemskipalign{%
	\CF@doifempty\CF@bond@outcontentsaved% sauf si un \chemskipalign a été fait à l'atome précédent
		{\global\let\CF@bond@outcontentsaved\CF@bond@outcontent}% sauvegarder l'atome d'où vient la liaison
	\let\CF@node@strut\empty
}

\def\CF@empty@node{{}}

\def\definesubmol{\CF@definesubmoltrue\def@submol}
\def\redefinesubmol{\CF@definesubmolfalse\def@submol}

\def\def@submol#1{%
	\CF@cnt@atomingroup=0 % nombre d'arguments supposé
	\def\CF@tmp@str{#1}% nom
	\futurelet\CF@toks@a\CF@test@nxttok
}

\def\CF@test@nxttok{%
	\if[\noexpand\CF@toks@a\expandafter\CF@execfirst\else\expandafter\CF@execsecond\fi
		{\CF@exp@macroarg\CF@grab@optalias{\CF@tmp@str}}%
		{\afterassignment\CF@test@nxttok@a% pas d'argument entre crochet
		\CF@cnt@atomingroup=0% cherche le nombre d'arguments éventuel
		}%
}

\def\CF@test@nxttok@a{\futurelet\CF@toks@a\CF@test@nxttok@b}

\def\CF@test@nxttok@b{%
	\if[\noexpand\CF@toks@a\expandafter\CF@execfirst\else\expandafter\CF@execsecond\fi
		{\CF@exp@macroarg\CF@grab@optalias{\CF@tmp@str}}
		{\CF@exp@second{\def@submol@a}\CF@tmp@str{}}%
}

\def\CF@grab@optalias#1[#2]#{\def@submol@a{#1}{#2}}

\def\CF@make@listofargs#1{%
	\toks\z@{}%
	\CF@cnt@groupnumber#1\relax
	\CF@make@listofargs@a1%
}

\def\CF@make@listofargs@a#1{%
	\unless\ifnum#1>\CF@cnt@groupnumber
		\toks\z@\expandafter{\the\toks\z@###1}%
		\expandafter\CF@make@listofargs@a\expandafter{\number\numexpr#1+1\expandafter}%
	\fi
}

\def\def@submol@a#1{% #1 nom
	\ifcat\relax\expandafter\noexpand\CF@firsttonil#1\@nil\expandafter\CF@execfirst\else\expandafter\CF@execsecond\fi% si #1 est une séquence de contrôle
		{\expandafter\ifdefined\CF@firsttonil#1\@nil
			\ifCF@definesubmol
				\immediate\write-1{Package \CFname\space Warning: the submol \expandafter\string\CF@firsttonil#1\@nil\space is already defined, the previous definition is lost}%
			\fi
		\fi
		\def@submol@b{#1}%
		}
		{\ifcsname CF@@#1\endcsname
			\ifCF@definesubmol
				\immediate\write-1{Package \CFname\space Warning:the submol "#1" is already defined, the previous definition is lost}%
			\fi
		\fi
		\expandafter\def@submol@b\csname CF@@#1\endcsname
		}%
}

\def\def@submol@b#1#2#3{% #1 nom sous forme de macro, #2 = code si liaison arrive de droite , #3 = code si liaison arrive de gauche, \CF@cnt@atomingroup = nombre d'arguments
	\CF@make@listofargs\CF@cnt@atomingroup
	\CF@ifempty{#2}%
		{\CF@exp@after{\expandafter\def\CF@firsttonil#1\@nil}{\the\toks\z@}{\empty#3}}
		{\CF@exp@after{\expandafter\def\CF@firsttonil#1\@nil}{\the\toks\z@}{%
			\romannumeral
			\ifdim\CF@current@angle pt>90pt
				\ifdim\CF@current@angle pt<270pt
					\expandafter\expandafter\expandafter\CF@execfirst
				\else
					\expandafter\expandafter\expandafter\CF@execsecond
				\fi
			\else
				\expandafter\CF@execsecond
			\fi
			{\z@#2}{\z@#3}}%
		}%
}

\def\CF@seek@node#1#2#3{% cherche un noeud au début de #1 l'assigne dans la sc #2 et met le reste dans #3
	\let#2\empty
	\def#3{#1}%
	\CF@if@firsttokmatch{#1}{ }%
		{\CF@exp@macroarg\CF@seek@node@a{\romannumeral-`\.\noexpand#1}#2#3}% ignore les espaces au début du groupe d'atome
		{\CF@seek@node@a{#1}#2#3}%
}

\def\CF@seek@node@a#1#2#3{%
	\CF@ifempty{#1}%
		{\let#3\empty}
		{\futurelet\CF@toks@a\CF@gobtonil#1\relax\@nil
		\CF@ifx\CF@toks@a\@sptoken
			{\CF@add@tocs#2{ }%
			\CF@exp@macroarg\CF@seek@node@a{\CF@after@space#1\@nil}#2#3%
			}%
			{\CF@ifx\CF@toks@a\bgroup
				{\CF@eadd@tocs#2{\expandafter{\CF@firsttonil#1\@nil}}%
				\CF@exp@macroarg\CF@seek@node@a{\CF@gobarg#1}#2#3%
				}%
				{\CF@if@firsttokin@a{-=(*<>!~}%
					{\def#3{#1}}%
					{\CF@eadd@tocs#2{\CF@firsttonil#1\@nil}%
					\CF@exp@macroarg\CF@seek@node@a{\CF@gobarg#1}#2#3%
					}%
				}%
			}%
		}%
}

% on sait que #1 commence par -,=,~,<,>. On analyse cette liaison
% #2 reçoit le type de liaisons (1 pour -, 2 pour =, 3 pour ~)
\def\CF@bond@findcode#1#2{%
	\futurelet\CF@toks@a\CF@gobtonil#1\@nil
	\edef#2{%
		\ifx-\CF@toks@a1\else
		\ifx=\CF@toks@a2\else
		\ifx~\CF@toks@a3\else
		\ifx>\CF@toks@a4\else
		\ifx<\CF@toks@a5\else0% si 0 --> il y a une erreur non due à l'utilisateur
		\fi\fi\fi\fi\fi}%
	\ifnum#2>\thr@@% si c'est une liaison de Cram
		\CF@exp@after{\futurelet\CF@toks@a\CF@gobtonil}{\CF@gobarg#1\@nil}% chope le caractère suivant
		\CF@ifx:\CF@toks@a
			{\edef#2{\number\numexpr#2+2}}% si c 'est un ":", signe du pointillé, ajoute 2
			{\CF@ifx|\CF@toks@a{\edef#2{\number\numexpr#2+4}}{}}% si c 'est un "|", signe du triangle évidé, ajouter 4
	\fi
}

\def\CF@analyse@bondoffset#1,#2\@nil{%
	\def\CF@start@offset{#1}\def\CF@end@offset{#2}%
}

\def\CF@grab@bondoffset#1(#2)#3\@nil{%
	\CF@doifnotempty{#2}%
		{\CF@if@instr{#2},%
			{\CF@analyse@bondoffset#2\@nil}%
			{\def\CF@start@offset{#2}}%
		}%
	\def\CF@remain@afterbond{#3}%
}

\def\CF@analyse@bond#1#2{%
	\CF@bond@findcode{#1}#2%
	\CF@exp@second{\def\CF@remain@afterbond}{\CF@gobarg#1}%mange le premier signe de la liaison
	\let\CF@doublebond@type\z@
	\ifnum#2=\tw@% si c'est une double liaison, regarde s'il y a un + ou - derrière
		\CF@exp@after{\futurelet\CF@toks@a\CF@gobtonil}{\CF@gobarg#1\@nil}%
		\CF@ifx^\CF@toks@a
			{\let\CF@doublebond@type\@ne
			\CF@exp@second{\def\CF@remain@afterbond}{\CF@gobtwoargs#1}% mange le "^"
			}
			{\ifx_\CF@toks@a
				\let\CF@doublebond@type\tw@
				\CF@exp@second{\def\CF@remain@afterbond}{\CF@gobtwoargs#1}% mange le "_"
			\fi
			}%
	\else
		\ifnum#2>5 % si c'est une laision de Cram pointillée ou triangle évidé
			\CF@exp@second{\def\CF@remain@afterbond}{\CF@gobtwoargs#1}% mange un caractère de plus
		\fi
	\fi
	\CF@exp@twomacroargs\CF@if@firsttokmatch\CF@remain@afterbond\CF@hash%
		{\expandafter\CF@grab@bondoffset\CF@remain@afterbond\@nil}%
		{}%
	\CF@exp@twomacroargs\CF@if@firsttokmatch\CF@remain@afterbond\CF@arobas
		{\expandafter\CF@grab@movearg\CF@remain@afterbond\@nil}%
		{}%
	\CF@exp@macroarg\CF@if@firsttokmatch{\CF@remain@afterbond}[%
		{\expandafter\CF@analyse@optarg\CF@remain@afterbond\@nil\CF@remain@afterbond}%
		{\let\CF@current@stringangle\default@stringangle
		\let\CF@current@length\default@length
		\let\CF@current@fromatom\default@fromatom
		\let\CF@current@toatom\default@toatom
		\let\CF@current@tikz\default@tikz
		\let\CF@movebond@name\empty
		}%
	\ifCF@incycle
		\pgfmathsetmacro\CF@cycle@increment@angle{360/\CF@cycle@num+\CF@initcycle@angle}%
		\edef\CF@current@stringangle{::+\CF@cycle@increment@angle}%
		\def\CF@initcycle@angle{0}%
		\let\CF@current@length\default@length% et on ignore la longueur de liaison spécifiée
	\fi
	\CF@exp@macroarg\CF@set@bondangle{\CF@current@stringangle}\CF@current@angle
}

\def\CF@set@bondangle#1#2{% le code de la direction est contenu dans #1, en sortie, #2 contient l'angle
	\CF@ifempty{#1}%
		{\let#2\default@angle}
		{\if:\expandafter\noexpand\CF@firsttonil#1\@nil
			\if:\CF@three@ea\noexpand\expandafter\CF@firsttonil\CF@gobarg#1\@nil
				\pgfmathsetmacro#2{\CF@previous@angle+\expandafter\CF@gobarg\CF@gobarg#1}%
			\else
				\pgfmathsetmacro#2{\CF@gobarg#1}%
			\fi
		\else
			\pgfmathsetmacro#2{#1*\CF@angle@increment}%
		\fi% puis normalise l'angle entre 0 et 360
		\ifdim\ifdim#2pt<\z@-\fi#2pt>360pt \pgfmathsetmacro#2{#2-360*floor(#2/360)}\fi% si |#2|>360
		\ifdim#2pt<\z@\pgfmathsetmacro#2{#2+360}\fi
		}%
}

\def\CF@int@part#1.#2\@nil{#1 }

\def\CF@analyse@movearg#1,#2\@nil#3{%
	\def#3{#1}\def\CF@movebond@coeff{#2}%
}

% Argument limités légitimes ici car #2 (qui est ce qui suit "@{<nom>}" dans l'argument optionnel) ne DOIT
% pas commencer par une accolade.
\expandafter\def\expandafter\CF@grab@movearg\CF@arobas#1#2\@nil{%
	\CF@if@instr{#1},%
		{\CF@analyse@movearg#1\@nil\CF@movebond@name}%
		{\def\CF@movebond@name{#1}\def\CF@movebond@coeff{0.5}}%
	\def\CF@remain@optarg{#2}%
}

\def\CF@testempty@andassign#1#2#3{\CF@ifempty{#2}{\let#1#3}{\def#1{#2}}}

\def\CF@parse@optlist#1,#2,#3,#4,#5\@nil{%
	\CF@testempty@andassign\CF@current@stringangle{#1}\default@stringangle
	\CF@testempty@andassign\CF@current@length{#2}\default@length
	\CF@testempty@andassign\CF@current@fromatom{#3}\default@fromatom
	\CF@testempty@andassign\CF@current@toatom{#4}\default@toatom
	\expandafter\CF@testempty@andassign\expandafter\CF@current@tikz\expandafter{\CF@sanitize@lastitem#5,\empty\@nil}\default@tikz
}%

\def\CF@analyse@optarg[#1]#2\@nil#3{%
	\CF@doifnotempty{#1}%
		{\CF@exp@after{\CF@if@firsttokmatch{#1}}{\CF@arobas}%
			{\CF@grab@movearg#1\@nil}%
			{\let\CF@movebond@name\empty
			\def\CF@remain@optarg{#1}%
			}%
		\expandafter\CF@parse@optlist\CF@remain@optarg,\empty,\empty,\empty,\empty\@nil
		\def#3{#2}%
		}%
}

\def\CF@seek@submol{%
	\CF@exp@second{\def\CF@remain@molecule}{\romannumeral-`\.\expandafter\noexpand\CF@remain@molecule}%
	\CF@exp@macroarg\CF@if@firsttokmatch{\CF@remain@molecule}!%
		{\CF@eexp@second{\def\CF@remain@molecule}{\expandafter\CF@gobarg\CF@remain@molecule}% enlève le "!"
		\CF@ifx\empty\CF@remain@molecule{\errmessage{Package \CFname\space Error: no submol name found after "!"}}{}%
		\ifcat\relax\CF@three@ea\noexpand\expandafter\CF@firsttonil\CF@remain@molecule*\@nil
			\CF@eexp@second{\CF@exp@second{\def\CF@remain@molecule}}{\CF@remain@molecule}%
		\else
			\expandafter\CF@seek@submol@a\CF@remain@molecule\@nil
		\fi
		\CF@seek@submol
		}%
		{}%
}

\def\CF@seek@submol@a#1#2\@nil{% #1=nom
	\CF@eexp@second{\CF@exp@second{\def\CF@remain@molecule}}{\csname CF@@#1\endcsname#2}%
}

\def\CF@insert@emptygroup#1{% insère {} au début de la sc #1
	\CF@exp@second{\def#1}{\expandafter{\expandafter}#1}%
}

\def\chemfig{%
	\CF@ifstar
		{\CF@warning{Do not use star \string\chemfig\space but set the key "fixed lengths"}%
		\CF@macrofixedbondlengthtrue\CF@chemfig@a
		}
		{\ifboolKV[chemfig]{fixed length}
			\CF@macrofixedbondlengthtrue
			\CF@macrofixedbondlengthfalse
		\CF@chemfig@a}%
}

\def\CF@chemfig@a{\CF@testopt\CF@chemfig@b{}}

\def\CF@chemfig@b[#1]{\CF@testopt{\CF@chemfig@c[#1]}{}}

\def\CF@chemfig@c[#1][#2]{%
	\if\relax\detokenize{#1#2}\relax\else
		\CF@warning{Do not use optional arguments but set the keys "tikz node style" and "tikz code"}%
	\fi
	\edef\CF@tmp@str{[remember picture,every node/.style={anchor=base,inner sep=\z@,outer sep=\z@,minimum size=\z@,\ifx\empty#2\empty\useKV[chemfig]{atom style}\else#2\fi},baseline,\ifx\empty#1\empty\useKV[chemfig]{chemfig style}\else#1\fi]}%
	\CF@exp@threemacroargs\CF@chemfig@d\CF@begin@tikzpicture\CF@tmp@str\CF@end@tikzpicture
}

\def\CF@chemfig@d#1#2#3#4{%
	#1#2%
	\begingroup
		\let\CF@hook@list\empty
		\ifboolKV[chemfig]{bond join}
			{\let\CF@draw@axisbond\CF@draw@axisbond@join}
			{\let\CF@draw@axisbond\CF@draw@axisbond@nojoin}%
		\ifboolKV[chemfig]{cram rectangle}
			{\let\CF@clipcramornot\CF@gobtikzinstruction}
			{\let\CF@clipcramornot\clip}%
		\CF@valuetomacro\CF@cram@basewidth[1.5ex]{cram width}%
		\CF@valuetomacro\CF@cram@dashlength[1pt]{cram dash width}%
		\CF@valuetomacro\CF@cram@dashsep[2pt]{cram dash sep}%
		\CF@valuetomacro\CF@atom@sep[3em]{atom sep}% espacement des atomes liés
		\CF@valuetomacro\CF@bond@offset[2pt]{bond offset}%
		\CF@valuetomacro\CF@double@sep[2pt]{double bond sep}%
		\CF@valuetomacro\CF@angle@increment[45]{angle increment}%
		\CF@valuetomacro\CF@node@style[]{node style}%
		\CF@valuetomacro\CF@bond@style[]{bond style}%
		\CF@valuetomacro\CF@stacksep[1.5pt]{stack sep}%
		\CF@valuetomacro\CF@cycle@inraduiscoeff[0.75]{cycle radius coeff}% coeff multiplicateur du rayon des arcs dans les cycles
		\CF@incyclefalse
		\CF@cnt@groupnumber\z@
		\let\CF@last@action\z@% 0=début du dessin 1=tracé d'un noeud 2=tracé d'une liaison
		\let\CF@start@offset\empty
		\let\CF@end@offset\empty
		\let\CF@bond@outcontentsaved\empty
		\def\CF@cycle@anglecorrection{180/\CF@cycle@num}%
		\def\default@angle{0}%
		\def\default@stringangle{:0}% angle pris par défaut si le champ est vide
		\def\default@length{1}%
		\let\default@fromatom\empty% numero de l'atome d'où partent les liaisons par défaut
		\let\default@toatom\empty% numéro de l'atome où arrivent les laisons par défaut
		\let\default@tikz\empty
		\let\CF@previous@bondangle\empty
		\let\CF@joinbond\z@
		\let\CF@previous@tikz\empty
		\everyeof{\@nil}\endlinechar-1
		\CF@sanitize@catcode
		\expandafter\assign@tonil\expandafter\CF@remain@molecule\scantokens{#4}%
		\CF@exp@macroarg\CF@chemfig@e{\CF@remain@molecule}%
	#3%
	\let\CF@split@state\z@
}

\def\CF@chemfig@e#1{% #1 est le code de la molécule
	\ifnum\CF@last@action=\thr@@
		\ifCF@incycle
			\def\default@angle{0}%
		\else
			\ifnum\CF@cnt@cycle=\z@% si c'est le début d'un cycle
				\pgfmathsetmacro\default@angle{\CF@previous@angle+180+\CF@cycle@anglecorrection}% on met la liaison à +180° + correction
			\else
				\pgfmathsetmacro\default@angle{\CF@previous@angle-90+180/\CF@cycle@num}% sinon à la bissectrice du sommet du cycle
			\fi
		\fi
		\let\default@stringangle\empty
	\fi
	\let\CF@current@angle\default@angle
	\def\CF@remain@molecule{#1}%
	\CF@seek@submol% alias en premier ?
	\if[\CF@three@ea\noexpand\expandafter\CF@firsttonil\CF@remain@molecule\@nil
		\expandafter\CF@analyse@optarg\CF@remain@molecule\@nil\CF@remain@molecule
		\CF@exp@macroarg\CF@set@bondangle{\CF@current@stringangle}\CF@current@angle
		\let\default@angle\CF@current@angle
		\let\CF@previous@angle\CF@current@angle
		\CF@doifnotempty\CF@current@stringangle{\let\default@angle\CF@current@angle}%
		\CF@doifnotempty\CF@current@length{\let\default@length\CF@current@length}%
		\CF@doifnotempty\CF@current@fromatom{\let\default@fromatom\CF@current@fromatom}%
		\CF@doifnotempty\CF@current@toatom{\let\default@toatom\CF@current@toatom}%
		\CF@doifnotempty\CF@current@tikz{\let\default@tikz\CF@current@tikz}%
		\CF@seek@submol
	\fi
	\edef\default@stringangle{:\default@angle}%
	\let\CF@current@length\default@length
	\let\CF@current@fromatom\default@fromatom
	\let\CF@current@toatom\default@toatom
	\let\CF@current@tikz\default@tikz
	\ifCF@incycle% si on commence un cycle
		\let\CF@current@angle\CF@previous@angle
		\ifCF@cyclearc% on doit tracer l'arc de cercle dans le cycle ?
			\pgfmathsetmacro\CF@cyclearc@radius{\CF@cycle@inraduiscoeff*\CF@current@length*\CF@atom@sep/(2*tan(180/\CF@cycle@num))}%
			\pgfmathsetmacro\CF@cyclearc@initangle{\CF@current@angle+\CF@initcycle@angle+180/\CF@cycle@num+90}
			\pgfmathparse{\CF@current@length*\CF@atom@sep/(2*sin(180/\CF@cycle@num))}%
			\node[at=(\CF@bond@outnode),shift=(\CF@cyclearc@initangle:\pgfmathresult pt)](arccenter){};% le centre de l'arc
			\node[at=(arccenter),shift=(\CF@cyclearc@startangle:\CF@cyclearc@radius pt)](initarc){};% le début de l'arc
			\expandafter\draw\expandafter[\CF@cyclearc@directtikz](initarc) arc (\CF@cyclearc@startangle:\CF@cyclearc@endangle:\CF@cyclearc@radius pt);
		\fi
	\else
		\let\CF@current@angle\default@angle
	\fi
	\ifnum\CF@last@action=\z@
		\let\CF@previous@angle\default@angle
		\node(CF@node){};
		\CF@exp@macroarg\CF@if@firsttokin{\CF@remain@molecule}{-=(*~?<>}%
			{\CF@insert@emptygroup\CF@remain@molecule}%
			{}%
	\fi
	\CF@chemfig@f
}

\def\CF@chemfig@f{%
	\let\CF@next@action\CF@chemfig@f% à priori, on reboucle
	\CF@ifx\CF@remain@molecule\empty
		{\let\CF@next@action\endgroup}
		{\CF@seek@submol
		\CF@exp@macroarg\CF@seek@node{\CF@remain@molecule}\CF@current@atomgroup\CF@remain@molecule
		\CF@ifx\empty\CF@current@atomgroup% pas de noeud pour commencer ?
			{\def\CF@bond@outnode{%
				n\CF@last@groupnumber-%
				\ifx\CF@current@fromatom\empty
					\ifdim\CF@current@angle pt<90pt \number\CF@cnt@atomingroup
					\else\ifdim\CF@current@angle pt>270pt \number\CF@cnt@atomingroup\else1\fi
					\fi
				\else
					\CF@current@fromatom
				\fi}%
			\CF@exp@after{\futurelet\CF@toks@a\CF@gobtonil}{\CF@remain@molecule\relax\@nil}%
			\CF@if@firsttokin@a{-=<>~}% la suite est une liaison
				{\ifnum\CF@last@action=\tw@% c'est la deuxième liaison consécutive ?
					\CF@insert@emptygroup\CF@remain@molecule% insère un groupe vide
					\edef\CF@bond@outnode{\CF@bond@outnode}%
				\else
					\ifCF@incycle\advance\CF@cnt@cycle\@ne\fi
					\CF@exp@macroarg\CF@analyse@bond{\CF@remain@molecule}\CF@bond@type
					\edef\CF@bond@outnode{\CF@bond@outnode}%
					\let\CF@remain@molecule\CF@remain@afterbond
					\ifCF@incycle
						\ifnum\CF@cnt@cycle=\CF@cycle@num\relax
							\CF@three@ea\CF@execfirst
						\else
							\ifnum\CF@cnt@cycle=\@ne
								\let\CF@cycle@firsttikz\CF@current@tikz
								\CF@doifnotempty\CF@start@offset{\let\CF@cycle@joinlast\z@}%
							\fi
							\CF@three@ea\CF@execsecond
						\fi
					\else
						\expandafter\CF@execsecond
					\fi
						{\let\CF@next@action\endgroup
						\CF@draw@bond\CF@bond@type{\CF@bond@outnode}{\CF@hook@cycle}\CF@previous@atomgroup\CF@hook@atomgroup
						}%
						{\node[at=(\CF@bond@outnode\ifCF@incycle\else\ifCF@macrofixedbondlength.\CF@current@angle\fi\fi),shift=(\ifcase\CF@split@state\or180-\or-\fi\CF@current@angle:\CF@current@length*\CF@atom@sep)](CF@node){};
						\let\CF@previous@angle\CF@current@angle
						\let\CF@last@action\tw@
						}%
				\fi
				\ifcat\relax\detokenize\expandafter{\romannumeral-`\.\expandafter\noexpand\CF@remain@molecule}\relax
				% s'il ne reste plus rien après la liaison (sans tenir compte de l'espace devant)-> insère un groupe vide
					\CF@insert@emptygroup\CF@remain@molecule
				\fi
				}%
				{\edef\CF@bond@outnode{\CF@bond@outnode}% évalue le l'atome de départ de liaison
				\CF@ifx(\CF@toks@a% une parenthèse pour commencer ?
					{\ifnum\CF@last@action=\tw@% il y avait une liaison juste avant ?
						\CF@insert@emptygroup\CF@remain@molecule
					\else
						\CF@exp@macroarg\CF@grab@submol{\CF@remain@molecule}%
						\begingroup
							\ifCF@incycle\let\CF@last@action\thr@@\fi% on était dans un cycle
							\CF@incyclefalse
							\aftergroup\CF@chemfig@f
							\def\CF@next@action{\CF@exp@macroarg\CF@chemfig@e{\CF@sub@mol}}%
					\fi
					}%
					{\CF@ifx\CF@remain@molecule\empty
						{\let\CF@next@action\endgroup}
						{% ce qui reste après le noeud courant n'est pas vide, ne commence pas par "-=~", ni par une parenthèse
						\CF@ifx*\CF@toks@a% un cycle ?
							{\ifnum\CF@last@action=\tw@
								\CF@insert@emptygroup\CF@remain@molecule% insère un groupe vide
							\else
								\ifCF@incycle\let\CF@last@action\thr@@\fi% on était dans un cycle
								\ifnum\CF@last@action=\thr@@\let\CF@lastcycle@num\CF@cycle@num\fi
								\CF@eexp@macroarg\CF@if@firsttokmatch{\expandafter\CF@gobarg\CF@remain@molecule}*%
									{\CF@eexp@second{\def\CF@remain@molecule}{\expandafter\CF@gobarg\CF@remain@molecule}% enlève la 1er étoile
									\CF@eexp@macroarg\CF@if@firsttokmatch{\expandafter\CF@gobarg\CF@remain@molecule}[% un crochet ensuite ?
										{\expandafter\CF@cycle@parsepreamblewithoptarg\CF@remain@molecule\@nil% \begingroup inclus
										}%
										{\def\CF@cyclearc@startangle{0}\def\CF@cyclearc@endangle{360}%
										\let\CF@cyclearc@directtikz\empty
										\expandafter\CF@cycle@parsepreamble\CF@remain@molecule\@nil% \begingroup inclus
										}%
									\CF@cyclearctrue
									}%
									{\expandafter\CF@cycle@parsepreamble\CF@remain@molecule\@nil% \begingroup inclus
									\CF@cyclearcfalse
									}%
								\CF@cnt@cycle\z@
								\edef\CF@hook@cycle{\CF@bond@outnode}%
								\let\CF@hook@atomgroup\CF@previous@atomgroup
								\CF@ifx\CF@hook@atomgroup\CF@empty@node
									{\let\CF@cycle@joinlast\@ne}% joindre le dernier
									{\let\CF@cycle@joinlast\z@}
								\CF@incycletrue
								\ifnum\CF@last@action=\thr@@
									\pgfmathsetmacro\CF@initcycle@angle{360/\CF@lastcycle@num-180}% c'est un cycle dans un cycle
								\else
									\pgfmathsetmacro\CF@initcycle@angle{-180/\CF@cycle@num-90+\CF@cycle@anglecorrection}%
								\fi
								\aftergroup\CF@chemfig@f
								\def\CF@next@action{\CF@exp@macroarg\CF@chemfig@e{\CF@sub@mol}}%
							\fi
							}%
							{\errmessage{Package \CFname\space Error: something went wrong here: \detokenize\expandafter{\CF@remain@molecule}^^JIf you think it's a bug, please, send a Minimal Example to the author.}%
							}%
						}%
					}%
				}%
			}%
			{\CF@exp@threemacroargs\CF@draw@atomgroup\CF@current@angle\CF@current@toatom\CF@current@atomgroup
			}%
		}%
	\CF@next@action
}

\def\CF@cycle@parsepreamble*#1#2\@nil{%
	\ifnum#1<\thr@@
		\errmessage{Package \CFname\space Error: A cycle must be at least a triangle.^^JThe number following "*" must be 3 or more}%
	\fi
	\def\CF@remain@molecule{#2}%
	\CF@exp@macroarg\CF@grab@submol{\CF@remain@molecule}%
	\begingroup
	\def\CF@cycle@num{#1}%
}

\def\CF@cycle@parsepreamblewithoptarg*[#1]#2#3\@nil{%
	\CF@cycle@parseoptarg#1,\empty,\empty,\empty\@nil
	\CF@cycle@parsepreamble*#2#3\@nil
}

\def\CF@cycle@parseoptarg#1,#2,#3\@nil{%
	\CF@ifempty{#1}{\def\CF@cyclearc@startangle{0}}{\def\CF@cyclearc@startangle{#1}}%
	\CF@ifempty{#2}{\def\CF@cyclearc@endangle{360}}{\def\CF@cyclearc@endangle{#2}}%
	\CF@exp@second{\def\CF@cyclearc@directtikz}{\CF@sanitize@lastitem#3,\empty\@nil}%
}

\def\CF@grab@submol#1{%
	\begingroup
		\catcode`(\@ne\catcode`)\tw@
		\CF@three@ea
	\endgroup
	\expandafter\CF@grab@submol@a\scantokens{\relax#1}%
}

\def\CF@grab@submol@a#1\@nil{%
	\expandafter\assign@tonil\expandafter\CF@remain@molecule\scantokens\CF@three@ea{\expandafter\CF@gobarg\CF@gobarg#1}%
	\expandafter\assign@tonil\expandafter\CF@sub@mol\scantokens\CF@three@ea{\expandafter\CF@firsttonil\CF@gobarg#1\@nil}%
}

\def\assign@tonil#1#2\@nil{\def#1{#2}}

\def\CF@ifcar@isupperletter#1{%
	\ifcat\relax\noexpand#1%
		\let\CF@next\CF@execsecond% faux si c'est une sc
	\else
		\ifnum`#1<`A
			\let\CF@next\CF@execsecond
		\else
			\ifnum`#1>`Z
				\let\CF@next\CF@execsecond
			\else
				\let\CF@next\CF@execfirst
			\fi
		\fi
	\fi
	\CF@next
}

% Créé 4 noeuds au dessus et au dessous des noeuds #1 et #2
% à une distance de #3 du noeud #1 et #4 du noeud #2
\def\CF@create@normnodes#1#2#3#4{%
	\CF@doifnotempty{#3}
		{\node[shape=coordinate,at=(#1),xshift=#3*\CF@norm@x,yshift=#3*\CF@norm@y](#11){};
		\node[shape=coordinate,at=(#1),xshift=-#3*\CF@norm@x,yshift=-#3*\CF@norm@y](#12){};
		}%
	\CF@doifnotempty{#4}
		{\node[shape=coordinate,at=(#2),xshift=#4*\CF@norm@x,yshift=#4*\CF@norm@y](#21){};
		\node[shape=coordinate,at=(#2),xshift=-#4*\CF@norm@x,yshift=-#4*\CF@norm@y](#22){};
		}%
}

\def\CF@compute@nodevect#1#2{%
	\pgfextractx\CF@dim{\pgfpointanchor{#1}{center}}\edef\CF@dimax{\the\CF@dim}%
	\pgfextracty\CF@dim{\pgfpointanchor{#1}{center}}\edef\CF@dimay{\the\CF@dim}%
	\pgfextractx\CF@dim{\pgfpointanchor{#2}{center}}\edef\CF@dimbx{\the\CF@dim}%
	\pgfextracty\CF@dim{\pgfpointanchor{#2}{center}}\edef\CF@dimby{\the\CF@dim}%
	\pgfmathsetmacro\CF@len@vector{veclen(\CF@dimbx-\CF@dimax,\CF@dimby-\CF@dimay)}%
	\pgfmathsetmacro\CF@norm@x{(\CF@dimay-\CF@dimby)/\CF@len@vector}%
	\pgfmathsetmacro\CF@norm@y{(\CF@dimbx-\CF@dimax)/\CF@len@vector}%
}

\def\CF@set@offset#1#2{%
	\CF@doifempty#1%
		{\edef#1{\ifx#2\CF@empty@node0pt\else\ifx#2\empty0pt\else\CF@bond@offset\fi\fi}}%
}

\def\CF@draw@bond#1#2#3#4#5{% #1=type de liaison #2 et #3:nom de noeuds de début et fin #4 et #5: contenu des atomes de début et fin
	\CF@set@offset\CF@start@offset#4%
	\CF@set@offset\CF@end@offset#5%
	\let\CF@current@bondstyle\CF@bond@style
	\CF@doifnotempty\CF@current@tikz{\CF@eadd@tocs\CF@current@bondstyle{\expandafter,\CF@current@tikz}}%
	\path(#2)--(#3)coordinate[pos=0](#2@)coordinate[pos=1](#3@);%
	\CF@compute@nodevect{#2@}{#3@}%
	\pgfmathsetmacro\CF@start@coeff{\CF@start@offset/\CF@len@vector}%
	\pgfmathsetmacro\CF@end@coeff{1-\CF@end@offset/\CF@len@vector}%
	\path(#2@)--(#3@)coordinate[pos=\CF@start@coeff](#2@@)coordinate[pos=\CF@end@coeff](#3@@);%
	\CF@doifnotempty\CF@movebond@name% on doit poser un noeud sur la liaison
		{\path(#2@@)--(#3@@)coordinate[overlay,pos=\CF@movebond@coeff](\CF@movebond@name);
		\let\CF@movebond@name\empty
		}%
	\ifcase#1\relax
		\errmessage{Package \CFname\space Error: unknown bond type, this error should not occur^^JIf you think it's a bug, send a Minimal Example to the author}%
	\or% 1 = liaison simple
		\CF@draw@axisbond{#2}{#3}% trace la liaison simple dans l'axe
	\or% 2 = liaison double
		\ifCF@incycle
			\ifnum\CF@doublebond@type=\z@
				\let\CF@doublebond@type\@ne
			\fi
			\ifnum\CF@split@state>\z@
				\let\CF@doublebond@type\tw@
			\fi
			\pgfmathsetmacro\CF@doublebond@lengthcorrection{\CF@double@sep*tan(180/\CF@cycle@num)}%
		\fi
		\ifcase\CF@doublebond@type
			\CF@create@normnodes{#2@@}{#3@@}{\CF@double@sep/2}{\CF@double@sep/2}%
			\CF@draw@bond@a(#2@@1)--(#3@@1);
			\CF@draw@bond@a(#2@@2)--(#3@@2);
			\let\CF@joinbond\z@
		\or
			\CF@create@normnodes{#2@@}{#3@@}\CF@double@sep\CF@double@sep
			\CF@draw@axisbond{#2}{#3}% trace la liaison simple dans l'axe\CF@draw@bond@a(#2@@)--(#3@@);
			\begingroup% ajuste éventuellement les longueurs des liaisons doubles
				\ifCF@incycle
					\ifdim\CF@start@offset=\z@
						\CF@edefadd@tocs\CF@current@bondstyle{,shorten <=\CF@doublebond@lengthcorrection pt}%
					\fi
					\ifdim\CF@end@offset=\z@
						\CF@edefadd@tocs\CF@current@bondstyle{,shorten >=\CF@doublebond@lengthcorrection pt}%
					\fi
				\fi
				\CF@draw@bond@a(#2@@1)--(#3@@1);
			\endgroup
		\or
			\CF@create@normnodes{#2@@}{#3@@}\CF@double@sep\CF@double@sep
			\CF@draw@axisbond{#2}{#3}% trace la liaison simple dans l'axe\CF@draw@bond@a(#2@@)--(#3@@);
			\begingroup% ajuste éventuellement les longueurs des liaisons doubles
				\ifCF@incycle
					\ifdim\CF@start@offset=\z@
						\CF@edefadd@tocs\CF@current@bondstyle{,shorten \ifnum\CF@split@state=\z@<=-\else>=\fi\CF@doublebond@lengthcorrection pt}%
					\fi
					\ifdim\CF@end@offset=\z@
						\CF@edefadd@tocs\CF@current@bondstyle{,shorten \ifnum\CF@split@state=\z@>=-\else<=\fi\CF@doublebond@lengthcorrection pt}%
					\fi
				\fi
				\CF@draw@bond@a(#2@@2)--(#3@@2);
			\endgroup
		\fi
	\or% 3 = liaison triple
		\CF@create@normnodes{#2@@}{#3@@}\CF@double@sep\CF@double@sep
		\CF@draw@axisbond{#2}{#3}% trace la liaison simple dans l'axe\CF@draw@bond@a(#2@@)--(#3@@);
		\CF@draw@bond@a(#2@@1)--(#3@@1);
		\CF@draw@bond@a(#2@@2)--(#3@@2);
	\or% 4 = liaison Cram pleine de #2 vers #3
		\CF@create@normnodes{#2@@}{#3@@}{\CF@cram@basewidth/2}{}%
		\expandafter\filldraw\expandafter[\CF@current@bondstyle,line join=bevel](#2@@1)--(#2@@2)--(#3@@)--cycle;
		\let\CF@joinbond\z@
	\or% 5 = liaison Cram creuse de #3 vers #2
		\CF@create@normnodes{#3@@}{#2@@}{\CF@cram@basewidth/2}{}%
		\expandafter\filldraw\expandafter[\CF@current@bondstyle,line join=bevel](#3@@1)--(#3@@2)--(#2@@)--cycle;
		\let\CF@joinbond\z@
	\or% 6 = liaison Cram pointillée de #2 vers #3
		\scope
			\CF@create@normnodes{#2@@}{#3@@}{\CF@cram@basewidth/2}{}%
			\CF@clipcramornot(#2@@1)--(#2@@2)--(#3@@)--(#2@@1);
			\expandafter\draw\expandafter[\CF@current@bondstyle,dash pattern=on \CF@cram@dashlength off \CF@cram@dashsep,line width=\CF@cram@basewidth](#2@@)--(#3@@);
		\endscope
		\let\CF@joinbond\z@
	\or% 7 = liaison Cram pointillée de #3 vers #2
		\scope
			\CF@create@normnodes{#3@@}{#2@@}{\CF@cram@basewidth/2}{}%
			\CF@clipcramornot(#3@@1)--(#3@@2)--(#2@@)--(#3@@1);
			\expandafter\draw\expandafter[\CF@current@bondstyle,dash pattern=on \CF@cram@dashlength off \CF@cram@dashsep,line width=\CF@cram@basewidth](#3@@)--(#2@@);
		\endscope
		\let\CF@joinbond\z@
	\or% 8 = liaison cram rectangle évidé de #2 vers #3
		\CF@create@normnodes{#2@@}{#3@@}{\CF@cram@basewidth/2}{}%
		\expandafter\draw\expandafter[\CF@current@bondstyle,line join=bevel](#2@@1)--(#2@@2)--(#3@@)--cycle;
		\let\CF@joinbond\z@
	\or% 9 = liaison cram rectangle évidé de #3 vers #1
		\CF@create@normnodes{#3@@}{#2@@}{\CF@cram@basewidth/2}{}%
		\expandafter\draw\expandafter[\CF@current@bondstyle,line join=bevel](#3@@1)--(#3@@2)--(#2@@)--cycle;
		\let\CF@joinbond\z@
	\else
		\errmessage{Package \CFname\space Error: unknown bond type, this error should not occur^^JIf you think it's a bug, send a Minimal Example to the author}%
	\fi
	\let\CF@start@offset\empty
	\let\CF@end@offset\empty
	\let\CF@previous@tikz\CF@current@tikz
	\let\CF@previous@bondangle\CF@previous@angle
	\def\CF@previous@bond{#1}%
}

\def\CF@draw@axisbond@nojoin#1#2{\CF@draw@bond@a(#1@@)--(#2@@);}

\def\CF@draw@axisbond@join#1#2{% dessine une liaison simple dans l'axe avec raccord rétrograde
	\ifCF@incycle\ifnum\CF@cnt@cycle=\CF@cycle@num\relax\let\CF@next@tikz\CF@cycle@firsttikz\fi\fi
	\ifnum\CF@joinbond=\z@
		\ifCF@incycle
			\ifnum\CF@cnt@cycle=\CF@cycle@num\relax
				\ifnum\CF@cycle@joinlast=\@ne
					\CF@draw@bond@a(#1@@)--(#2@@)--%
						([shift=(\CF@previous@bondangle+2*\CF@cycle@increment@angle:.5\pgflinewidth)]#2@@);
				\else
					\CF@draw@bond@a(#1@@)--(#2@@);
				\fi
			\else
				\CF@draw@bond@a(#1@@)--(#2@@);
			\fi
		\else
			\CF@draw@bond@a(#1@@)--(#2@@);
		\fi
		\let\CF@joinbond\@ne
	\else
		\CF@ifx\CF@previous@tikz\CF@current@tikz
			{\let\CF@joinbond\@ne
			\CF@ifx\CF@previous@atomgroup\CF@empty@node
				{\CF@ifx\CF@previous@bondangle\empty% si début molécule
					{\CF@draw@bond@a(#1@@)--(#2@@);
					}
					{\ifdim\CF@start@offset=\z@
						\ifCF@incycle
							\ifnum\CF@cnt@cycle=\CF@cycle@num\relax
								\ifnum\CF@cycle@joinlast=\@ne
									\CF@ifx\CF@cycle@firsttikz\CF@current@tikz
										{\CF@draw@bond@a([shift=(\CF@previous@bondangle:-.5\pgflinewidth)]#1@@)--(#1@@)--(#2@@)--%
										([shift=(\CF@previous@bondangle+2*\CF@cycle@increment@angle:.5\pgflinewidth)]#2@@);
										}
										{\CF@draw@bond@a([shift=(\CF@previous@bondangle:-.5\pgflinewidth)]#1@@)--(#1@@)--(#2@@);
										}%
								\else
									\CF@draw@bond@a([shift=(\CF@previous@bondangle:-.5\pgflinewidth)]#1@@)--(#1@@)--(#2@@);
								\fi
							\else
								\CF@draw@bond@a([shift=(\CF@previous@bondangle:-.5\pgflinewidth)]#1@@)--(#1@@)--(#2@@);
							\fi
						\else
							\CF@draw@bond@a([shift=(\CF@previous@bondangle:-.5\pgflinewidth)]#1@@)--(#1@@)--(#2@@);
						\fi
					\else
						\CF@draw@bond@a(#1@@)--(#2@@);
					\fi
					}%
				}
				{\CF@draw@bond@a(#1@@)--(#2@@);}%
			}
			{\ifCF@incycle
				\ifnum\CF@cnt@cycle=\CF@cycle@num\relax
					\ifnum\CF@cycle@joinlast=\@ne
						\CF@ifx\CF@next@tikz\CF@current@tikz
							{\CF@draw@bond@a(#1@@)--(#2@@)--%
								([shift=(\CF@previous@bondangle+2*\CF@cycle@increment@angle:.5\pgflinewidth)]#2@@);
							}%
							{\CF@draw@bond@a(#1@@)--(#2@@);
							}%
					\else
						\CF@draw@bond@a(#1@@)--(#2@@);
					\fi
				\else
					\CF@draw@bond@a(#1@@)--(#2@@);
				\fi
			\else
				\CF@draw@bond@a(#1@@)--(#2@@);
			\fi
			}%
	\fi
	\ifdim\CF@end@offset=\z@\else\let\CF@joinbond\z@\fi
}

\def\CF@draw@bond@a{\expandafter\draw\expandafter[\CF@current@bondstyle]}

\def\CF@hook@drawall{% dessine tous les crochets contenus dans la sc \CF@hook@draw
	\CF@doifnotempty\CF@hook@drawlist
		{\expandafter\CF@hook@drawfirst\CF@hook@drawlist\@nil% trace un lien de crochet à crochet
		\CF@hook@drawall
		}%
}

\def\CF@hook@drawfirst[#1,#2,#3]#4#5#6#7#8\@nil{%
	\def\CF@hook@drawlist{#8}%
	\begingroup
		\let\CF@joinbond\z@
		\def\CF@current@tikz{#3}%
		\def\CF@hook@startcontent{#6}\def\CF@hook@endcontent{#7}%
		\CF@if@integer{#2}%
			{\CF@draw@bond{#2}{#4}{#5}\CF@hook@startcontent\CF@hook@endcontent}%
			{\CF@bond@findcode{#2}\CF@bond@currentnum
			\CF@draw@bond\CF@bond@currentnum{#4}{#5}\CF@hook@startcontent\CF@hook@endcontent
			}%
	\endgroup
}

\def\CF@extract@atom#1-#2\@nil{#2}% transforme le bound@outnode en n° de l'atome

\expandafter\def\expandafter\CF@gobble@movearg\CF@arobas#1#2\@nil#3{%
	\expandafter\def\csname atom@\number\CF@cnt@atomnumber\endcsname{#2}%
	\CF@if@instr{#1},%
		{\CF@analyse@movearg#1\@nil#3\let\CF@movebond@coeff\empty}%
		{\def#3{#1}}%
	\CF@doifempty{#2}{\let\CF@node@strut\empty}%
}%

\def\hflipnext{\let\CF@split@state\@ne}

\def\vflipnext{\let\CF@split@state\tw@}
\let\CF@split@state\z@

\def\CF@draw@atomgroup#1#2#3{% #1=angle d'arrivée de la liaison #2=numero atome sur lequel arrive la liaison #3=groupe d'atomes
	\expandafter\let\expandafter\CF@bond@outcontent% assigne le contenu de l'atome d'où part la liaison
		\csname
			\ifdefined\CF@bond@outnode
				atom@\expandafter\CF@extract@atom\CF@bond@outnode\@nil
			\else
				@empty%
			\fi
		\endcsname
	\global\advance\CF@cnt@groupnumber\@ne
	\let\CF@current@atom\empty
	\global\let\CF@hook@drawlist\empty
	\CF@cnt@atomingroup\z@
	\CF@if@firsttokmatch{#3}?{\CF@draw@atomgroup@a{{}#3}}{\CF@draw@atomgroup@a{#3}}%
	\def\CF@current@atomgroup{#3}%
	\CF@remove@movearg\CF@current@atomgroup% enlève les "@{<nom>}"
	\CF@if@instr{#3}?%
		{\CF@remove@hook\CF@current@atomgroup
		\ifcat\relax\detokenize\expandafter{\romannumeral-`\.\expandafter\noexpand\CF@current@atomgroup}\relax
			\let\CF@current@atomgroup\CF@empty@node
		\fi
		}%
		{}%
	\CF@doifnotempty{#2}
		{\ifnum#2<\@ne
			\immediate\write-1{Package \CFname\space Warning: no atom found at position #2, pershaps you mispelled the optional argument of the bond.}%
		\else
			\ifnum#2>\CF@cnt@atomingroup
				\errmessage{Package \CFname\space Error: no atom found at position #2, pershaps you mispelled the optional argument of the bond.}%
			\fi
		\fi
		}%
	\edef\CF@hook@atomnumber{%
		\CF@ifempty{#2}
			{\ifdim#1pt>90pt
				\ifdim#1pt<270pt \number\CF@cnt@atomingroup\else1\fi
			\else1%
			\fi
			}
			{#2}%
	}%
	\CF@cnt@atomnumber\CF@hook@atomnumber
	\CF@ifx\CF@current@atomgroup\CF@empty@node
		{\let\CF@node@strut\empty}
		{\CF@ifx\empty\CF@bond@outcontentsaved
			{\def\CF@node@strut{\vphantom\CF@bond@outcontent}}%
			{\def\CF@node@strut{\vphantom\CF@bond@outcontentsaved}}%
		}%
	\edef\CF@opt@string{anchor=\ifnum\CF@last@action=\z@ base\else\ifCF@incycle center\else\ifCF@macrofixedbondlength 180+#1\else center\fi\fi\fi,at=(CF@node),\CF@node@style}% premier atome de la molécule affiché
	\loop
		\unless\ifnum\CF@cnt@atomnumber>\CF@cnt@atomingroup
		\CF@eexp@after
			{\futurelet\CF@toks@a}
			{\expandafter\expandafter\expandafter\CF@gobtonil\csname atom@\number\CF@cnt@atomnumber\endcsname\@nil}%
		\expandafter\CF@ifx\CF@arobas\CF@toks@a% l'atome courant commence par un "@"
			{\CF@three@ea\CF@gobble@movearg\csname atom@\number\CF@cnt@atomnumber\endcsname\@nil\CF@moveatom@name
			\expandafter\node\expandafter[\CF@opt@string,overlay](\CF@moveatom@name){\phantom{\CF@node@content}};%
			\let\CF@moveatom@name\empty
			}
			{}%
		\expandafter\node\expandafter[\CF@opt@string](n\number\CF@cnt@groupnumber-\number\CF@cnt@atomnumber){\CF@node@content};%
		\let\CF@node@strut\empty
		\advance\CF@cnt@atomnumber\@ne
		\edef\CF@opt@string{anchor=base \ifnum\CF@split@state=\@ne east\else west\fi,at=(n\number\CF@cnt@groupnumber-\number\numexpr\CF@cnt@atomnumber-1.base \ifnum\CF@split@state=\@ne west\else east\fi),\CF@node@style}%
	\repeat
	\CF@cnt@atomnumber\CF@hook@atomnumber
	\ifnum\CF@last@action=\tw@% s'il faut tracer une liaison
		\gdef\CF@cycle@anglecorrection{0}% alors c'est qu'un cycle ne peut pas commencer la molécule : annulation de la correction d'angle
		\CF@draw@bond\CF@bond@type{\CF@bond@outnode}{n\number\CF@cnt@groupnumber-\number\CF@cnt@atomnumber}\CF@previous@atomgroup\CF@current@atomgroup
	\fi
	\let\CF@last@action\@ne% met la dernière action à 1 : affichage d'un noeud
	\loop
		\ifnum\CF@cnt@atomnumber>\@ne
		\advance\CF@cnt@atomnumber-1
		\edef\CF@opt@string{anchor=base \ifnum\CF@split@state=\@ne west\else east\fi,at=(n\number\CF@cnt@groupnumber-\number\numexpr\CF@cnt@atomnumber+1.base \ifnum\CF@split@state=\@ne east\else west\fi),\CF@node@style}%
		\CF@eexp@after
			{\futurelet\CF@toks@a}
			{\expandafter\expandafter\expandafter\CF@gobtonil\csname atom@\number\CF@cnt@atomnumber\endcsname\@nil}%
		\expandafter\CF@ifx\CF@arobas\CF@toks@a% l'atome courant commence par un "@"
			{\CF@three@ea\CF@gobble@movearg\csname atom@\number\CF@cnt@atomnumber\endcsname\@nil\CF@moveatom@name
			\expandafter\node\expandafter[\CF@opt@string,overlay](\CF@moveatom@name){\phantom{\CF@node@content}};%
			\let\CF@moveatom@name\empty
			}
			{}%
		\expandafter\node\expandafter[\CF@opt@string](n\number\CF@cnt@groupnumber-\number\CF@cnt@atomnumber){\CF@node@content};%
	\repeat
	\CF@hook@drawall
	\edef\CF@last@groupnumber{\number\CF@cnt@groupnumber}%
	\let\CF@previous@atomgroup\CF@current@atomgroup
}

\expandafter\def\expandafter\CF@keep@movearg\CF@arobas#1#2\@nil{\CF@exp@second{\def\CF@current@atom}{\CF@arobas{#1}}}

\def\CF@draw@atomgroup@a#1{% transforme #1 en un groupe d'atomes
	\CF@ifempty{#1}
		{\expandafter\let\csname atom@\number\CF@cnt@atomingroup\endcsname\CF@current@atom}
		{\advance\CF@cnt@atomingroup\@ne
		\futurelet\CF@toks@a\CF@gobtonil#1\@nil
		\expandafter\CF@ifx\CF@arobas\CF@toks@a
			{\CF@keep@movearg#1\@nil
			\CF@remove@movearg@a#1\@nil\CF@after@movearg
			\CF@exp@macroarg\CF@draw@atomgroup@b{\CF@after@movearg}%
			}%
			{\let\CF@current@atom\empty
			\CF@draw@atomgroup@b{#1}%
			}%
		}%
}

\def\CF@draw@atomgroup@b#1{%
	\CF@ifempty{#1}
		{\expandafter\let\csname atom@\number\CF@cnt@atomingroup\endcsname\CF@current@atom}
		{\futurelet\CF@toks@a\CF@gobtonil#1\@nil
		\CF@ifx\bgroup\CF@toks@a
			{\CF@eadd@tocs\CF@current@atom{\expandafter{\CF@firsttonil#1\@nil}}%
			\CF@exp@macroarg\CF@draw@atomgroup@bi{\CF@gobarg#1}%
			}%
			{\CF@ifx\@sptoken\CF@toks@a
				{\CF@add@tocs\CF@current@atom{ }%
				\CF@exp@macroarg\CF@draw@atomgroup@bi{\CF@after@space#1\@nil}%
				}%
				{\CF@eadd@tocs\CF@current@atom{\CF@firsttonil#1\@nil}%
				\CF@exp@macroarg\CF@draw@atomgroup@bi{\CF@gobarg#1}%
				}%
			}%
		}%
}

% enlève tous les "@{nom}" de la sc #1
\def\CF@remove@movearg#1{%
	\CF@exp@after{\expandafter\CF@if@instr\expandafter{#1}}{\CF@arobas}%
		{\expandafter\CF@remove@movearg@a#1\@nil#1%
		\CF@remove@movearg#1%
		}%
		{}%
}

% enlève le premier "@{<nom>}" de l'argument et l'assigne à #2
\def\CF@remove@movearg@a#1\@nil#2{%
	\expandafter\def\expandafter\CF@remove@movearg@b\expandafter##\expandafter1\CF@arobas{%
		\CF@exp@second{\def#2}{\CF@gobarg##1}% mange le \relax
		\CF@remove@movearg@c\relax
	}%
	\def\CF@remove@movearg@c##1\@nil{\CF@eadd@tocs#2{\CF@gobtwoargs##1}}% mange le \relax et le <nom>
	\CF@remove@movearg@b\relax#1\@nil
}

\def\CF@draw@atomgroup@bi#1{% transforme #1 en un groupe d'atomes
	\CF@ifempty{#1}
		{\expandafter\let\csname atom@\number\CF@cnt@atomingroup\endcsname\CF@current@atom
		\let\CF@current@atom\empty
		}
		{\futurelet\CF@toks@a\CF@gobtonil#1\@nil
		\expandafter\CF@ifx\CF@arobas\CF@toks@a
			{\expandafter\let\csname atom@\number\CF@cnt@atomingroup\endcsname\CF@current@atom
			\let\CF@current@atom\empty
			\CF@draw@atomgroup@a{#1}%
			}%
			{\CF@ifx|\CF@toks@a
				{\expandafter\let\csname atom@\number\CF@cnt@atomingroup\endcsname\CF@current@atom
				\let\CF@current@atom\empty
				\CF@exp@macroarg\CF@draw@atomgroup@a{\CF@gobarg#1}%
				}%
				{\CF@ifx\@sptoken\CF@toks@a
					{\CF@add@tocs\CF@current@atom{ }%
					\CF@exp@macroarg\CF@draw@atomgroup@bi{\CF@after@space#1\@nil}%
					}%
					{\CF@ifx\bgroup\CF@toks@a
						{\CF@eadd@tocs\CF@current@atom{\expandafter{\CF@firsttonil#1\@nil}}%
						\CF@exp@macroarg\CF@draw@atomgroup@bi{\CF@gobarg#1}%
						}%
						{\CF@exp@macroarg\CF@ifcar@isupperletter{\CF@firsttonil#1\@nil}%
							{\expandafter\let\csname atom@\number\CF@cnt@atomingroup\endcsname\CF@current@atom
							\let\CF@current@atom\empty
							\CF@draw@atomgroup@a{#1}%
							}%
							{\CF@ifx?\CF@toks@a
								{\CF@exp@macroarg\CF@if@firsttokmatch{\CF@gobarg#1}[% un crochet après le "?"
									{\expandafter\CF@grab@optarg\CF@gobarg#1\@nil\CF@after@hook}%
									{\expandafter\CF@grab@optarg\expandafter[\expandafter]\CF@gobarg#1\@nil\CF@after@hook}%
								\CF@exp@twomacroargs\CF@if@instr{\CF@hook@list}{\expandafter(\CF@hook@currentname)}% crochet déjà défini ?
									{\CF@exp@macroarg\CF@hook@parselist{\CF@hook@currentname}% chercher les caractéristiques du crochet sauvegardé
									\CF@edefadd@tocs\CF@hook@drawlist{%
										[\CF@hook@currentname,\CF@hook@currentlink,\CF@hook@currenttikz]{\CF@hook@savedcoord}{n\number\CF@cnt@groupnumber-\number\CF@cnt@atomingroup}}%
									\CF@eadd@tocs\CF@hook@drawlist{\expandafter{\CF@hook@savedcontent}}%
									\CF@eadd@tocs\CF@hook@drawlist{\expandafter{\CF@current@atom}}% ajoute les 4 arguments à la liste des crochets à tracer
									\global\let\CF@hook@drawlist\CF@hook@drawlist
									}%
									{\CF@edefadd@tocs\CF@hook@list{(\CF@hook@currentname)|n\number\CF@cnt@groupnumber-\number\CF@cnt@atomingroup|}%
									\CF@eadd@tocs\CF@hook@list{\CF@current@atom|}%
									\global\let\CF@hook@list\CF@hook@list
									}%
								\CF@exp@macroarg\CF@draw@atomgroup@bi{\CF@after@hook}%
								}%
								{\CF@eadd@tocs\CF@current@atom{\CF@firsttonil#1\@nil}%
								\CF@exp@macroarg\CF@draw@atomgroup@bi{\CF@gobarg#1}%
								}%
							}%
						}%
					}%
				}%
			}%
		}%
}

\def\CF@kook@defaultname{a}
\def\CF@hook@defaultlink{-}
\def\CF@hook@defaulttikz{}

\def\CF@hook@parseoptarg#1,#2,#3\@nil{%
	\CF@testempty@andassign\CF@hook@currentname{#1}\CF@kook@defaultname
	\CF@testempty@andassign\CF@hook@currentlink{#2}\CF@hook@defaultlink
	\CF@testempty@andassign\CF@hook@currenttikz{#3}\CF@hook@defaulttikz
}

\def\CF@grab@optarg[#1]#2\@nil#3{%
	\CF@hook@parseoptarg#1,,\@nil
	\def#3{#2}%
}

\def\CF@hook@parselist#1{% #1 est le nom du noeud à retrouver
	\def\CF@hook@parselist@a##1(#1)|##2|##3|##4\@nil{\def\CF@hook@savedcoord{##2}\def\CF@hook@savedcontent{##3}}%
	\expandafter\CF@hook@parselist@a\CF@hook@list\@nil
}

\def\CF@remove@hook#1{%
	\CF@exp@macroarg\CF@if@instr{#1}?%
		{\expandafter\CF@remove@hook@a\expandafter\relax#1\@nil#1%
		\CF@remove@hook#1%
		}
		{}%
}

\def\CF@remove@hook@a#1?#2\@nil#3{%
	\CF@if@firsttokmatch{#2}[%
		{\CF@remove@hook@b#1?#2\@nil#3}
		{\CF@exp@second{\def#3}{\CF@gobarg#1#2}}%
}

\def\CF@remove@hook@b#1?[#2]#3\@nil#4{\CF@exp@second{\def#4}{\CF@gobarg#1#3}}

\def\Lewis{\CF@testopt{\CF@lewis@a{}}{1}}

\def\lewis{\CF@testopt{\CF@lewis@a{,overlay}}{1}}

\def\CF@lewis@a#1[#2]{%
	\CF@valuetomacro\CF@lewis@widthdouble[0.3ex]{lewis | width}%
	\CF@valuetomacro\CF@lewis@offset[0.4ex]{lewis sep}%
	\CF@valuetomacro\CF@lewis@length[1.5ex]{lewis length}%
	\CF@valuetomacro\CF@lewis@style[]{lewis style}%
	\CF@valuetomacro\CF@lewis@dist[0.3em]{lewis dist}%
	\CF@valuetomacro\CF@lewis@radius[0.15ex]{lewis radius}%
	\CF@ifempty{#2}{\def\CF@lewis@diagcoeff{1}}{\def\CF@lewis@diagcoeff{#2}}%
	\CF@lewis@b{#1}%
}

\def\CF@lewis@b#1#2{\CF@lewis@c#2\@nil{#1}}

\def\CF@lewis@c#1,#2\@nil#3{%
	\setbox\CF@lewis@box\hbox{\printatom{#2}}% mettre en dehors de tikzpicture (si \printatom ne passe pas en mode math)
	\tikzpicture[every node/.style={anchor=base,inner sep=\z@,outer sep=\z@,minimum size=\z@},baseline]%
		\CF@makeother;\CF@makeother:%
		\node(CF@lewis@anchor){};
		\def\CF@lewis@remainpos{#1}%
		\let\CF@lewis@previouspos\empty
		\loop
			\unless\ifx\CF@lewis@remainpos\empty
				\edef\CF@lewis@currentpos{\expandafter\CF@firsttonil\CF@lewis@remainpos\@nil}%
				\edef\CF@lewis@remainpos{\expandafter\CF@gobarg\CF@lewis@remainpos}%
				\pgfmathsetmacro\CF@lewis@x{\wd\CF@lewis@box/2+\ifcase\CF@lewis@currentpos\space1\or1\or0\or-1\or-1\or-1\or0\or1\fi*(\wd\CF@lewis@box/2)}%
				\pgfmathsetmacro\CF@lewis@y{\ht\CF@lewis@box/2+\ifcase\CF@lewis@currentpos\space0\or1\or1\or1\or0\or-1\or-1\or-1\fi*(\ht\CF@lewis@box/2\ifnum\CF@lewis@currentpos>4 +\dp\CF@lewis@box\fi)}%
				\edef\CF@lewis@xoffset{\ifcase\CF@lewis@currentpos\space1\or0.70711\or0\or-0.70711\or-1\or-0.70711\or0\or0.70711\fi}%
				\edef\CF@lewis@yoffset{\ifcase\CF@lewis@currentpos\space0\or0.70711\or1\or0.70711\or0\or-0.70711\or-1\or-0.70711\fi}%
				\ifodd\CF@lewis@currentpos\relax
					\pgfmathsetmacro\CF@lewis@current@offset{\CF@lewis@offset*\CF@lewis@diagcoeff}%%
				\else
					\let\CF@lewis@current@offset\CF@lewis@offset
				\fi
				\if.\expandafter\CF@firsttonil\CF@lewis@remainpos\relax\@nil
					\edef\CF@lewis@remainpos{\expandafter\CF@gobarg\CF@lewis@remainpos}%
					\CF@exp@after{\draw[fill,black,}{\CF@lewis@style#3]}%
						(\CF@lewis@x pt+\CF@lewis@xoffset*\CF@lewis@current@offset,\CF@lewis@y pt+\CF@lewis@yoffset*\CF@lewis@current@offset)circle(\CF@lewis@radius);%
				\else
					\if|\expandafter\CF@firsttonil\CF@lewis@remainpos\relax\@nil
						\edef\CF@lewis@remainpos{\expandafter\CF@gobarg\CF@lewis@remainpos}%
						\pgfmathsetmacro\CF@lewis@x{\CF@lewis@x pt+\CF@lewis@xoffset*\CF@lewis@current@offset}%
						\pgfmathsetmacro\CF@lewis@y{\CF@lewis@y pt+\CF@lewis@yoffset*\CF@lewis@current@offset}%
						\expandafter\draw\expandafter[\CF@lewis@style#3]%
							(\CF@lewis@x pt+\CF@lewis@length*\CF@lewis@yoffset/2 pt,\CF@lewis@y-\CF@lewis@length*\CF@lewis@xoffset/2 pt)--
							(\CF@lewis@x pt+\CF@lewis@length*\CF@lewis@yoffset/2 pt+\CF@lewis@xoffset*\CF@lewis@widthdouble,\CF@lewis@y-\CF@lewis@length*\CF@lewis@xoffset/2 pt+\CF@lewis@yoffset*\CF@lewis@widthdouble)--
							(\CF@lewis@x pt-\CF@lewis@length*\CF@lewis@yoffset/2 pt+\CF@lewis@xoffset*\CF@lewis@widthdouble,\CF@lewis@y+\CF@lewis@length*\CF@lewis@xoffset/2 pt+\CF@lewis@yoffset*\CF@lewis@widthdouble)--
							(\CF@lewis@x pt-\CF@lewis@length*\CF@lewis@yoffset/2 pt,\CF@lewis@y+\CF@lewis@length*\CF@lewis@xoffset/2 pt)--cycle;%
					\else
						\if:\expandafter\CF@firsttonil\CF@lewis@remainpos\relax\@nil
							\edef\CF@lewis@remainpos{\expandafter\CF@gobarg\CF@lewis@remainpos}%
							\pgfmathsetmacro\CF@lewis@x{\CF@lewis@x pt+\CF@lewis@xoffset*\CF@lewis@current@offset}%
							\pgfmathsetmacro\CF@lewis@y{\CF@lewis@y pt+\CF@lewis@yoffset*\CF@lewis@current@offset}%
							\CF@exp@after{\draw[fill,black,}{\CF@lewis@style#3]}%
								(\CF@lewis@x pt+\CF@lewis@dist*\CF@lewis@yoffset/2 pt,\CF@lewis@y-\CF@lewis@dist*\CF@lewis@xoffset/2 pt)circle(\CF@lewis@radius)%
								(\CF@lewis@x pt-\CF@lewis@dist*\CF@lewis@yoffset/2 pt,\CF@lewis@y+\CF@lewis@dist*\CF@lewis@xoffset/2 pt)circle(\CF@lewis@radius);%
						\else
							\pgfmathsetmacro\CF@lewis@x{\CF@lewis@x pt+\CF@lewis@xoffset*\CF@lewis@current@offset}%
							\pgfmathsetmacro\CF@lewis@y{\CF@lewis@y pt+\CF@lewis@yoffset*\CF@lewis@current@offset}%
							\expandafter\draw\expandafter[\CF@lewis@style#3]%
								(\CF@lewis@x pt+\CF@lewis@length*\CF@lewis@yoffset/2 pt,\CF@lewis@y-\CF@lewis@length*\CF@lewis@xoffset/2 pt)--%
								(\CF@lewis@x pt-\CF@lewis@length*\CF@lewis@yoffset/2 pt,\CF@lewis@y+\CF@lewis@length*\CF@lewis@xoffset/2 pt);%
						\fi
					\fi
			\fi
		\repeat
		\node[anchor=base west]at(CF@lewis@anchor){\box\CF@lewis@box};%
	\endtikzpicture
}

\def\Chembelow{\begingroup\let\CF@tmp@str\CF@gobarg\CF@chembelow@a}

\def\chembelow{\begingroup\let\CF@tmp@str\CF@id\CF@chembelow@a}

\def\CF@chembelow@a{\CF@testopt\CF@chembelow@b\CF@stacksep}

\def\CF@chembelow@b[#1]#2#3{%
	\setbox\CF@box@boxa\hbox{\printatom{#2}}%
	\expandafter\vtop\CF@tmp@str{to\ht\CF@box@boxa}{%
		\offinterlineskip
		\hbox{\printatom{#2}}%
		\kern#1\relax
		\hbox to\wd\CF@box@boxa{\hss\printatom{#3}\hss}%
		\CF@tmp@str\vss
		}%
	\endgroup
}

\def\Chemabove{\begingroup\let\CF@tmp@str\CF@gobarg\CF@chemabove@a}

\def\chemabove{\begingroup\let\CF@tmp@str\CF@id\CF@chemabove@a}

\def\CF@chemabove@a{\CF@testopt\CF@chemabove@b\CF@stacksep}

\def\CF@chemabove@b[#1]#2#3{%
	\setbox\CF@box@boxa\hbox{\printatom{#2}}%
	\expandafter\vbox\CF@tmp@str{to\ht\CF@box@boxa}{%
		\offinterlineskip
		\CF@tmp@str\vss
		\hbox to\wd\CF@box@boxa{\hss\printatom{#3}\hss}%
		\kern#1\relax
		\hbox{\printatom{#2}}%
	}%
	\endgroup
}

\def\chemmove{\CF@testopt\CF@chemmove{}}

\def\CF@chemmove[#1]#2{%
	\CF@doifnotempty{#2}%
		{\expandafter\tikzpicture\romannumeral\CF@ifempty{#1}%
			{\z@[overlay,remember picture,-CF]}
			{\z@[overlay,remember picture,-CF,#1]}%
			#2
		\endtikzpicture
		}%
}

\def\chemnameinit#1{%
	\setbox\CF@stuff@box\hbox{#1}%
	\xdef\CF@dp@max{\the\dp\CF@stuff@box}%
}
\let\CF@dp@max\z@

\def\CF@parse@molname#1\\#2\@nil{%
	\hbox to\CF@wd@stuffbox{\hss#1\hss}%
	\CF@doifnotempty{#2}{\CF@parse@molname#2\@nil}%
}

\def\chemname{%
	\CF@ifstar
		{\CF@name@dp@adjustfalse\CF@chemname@a}
		{\CF@name@dp@adjusttrue \CF@chemname@a}%
}

\def\CF@chemname@a{\CF@testopt\CF@chemname@b{1.5ex}}

\def\CF@chemname@b[#1]#2#3{%
	\setbox\CF@stuff@box\hbox{#2}%
	\edef\CF@wd@stuffbox{\the\wd\CF@stuff@box}\edef\CF@dp@stuffbox{\the\dp\CF@stuff@box}%
	\leavevmode
	\ifdim\CF@dp@max<\CF@dp@stuffbox\global\let\CF@dp@max\CF@dp@stuffbox\fi
	\vtop{%
		\box\CF@stuff@box
		\nointerlineskip
		\kern\dimexpr#1\ifCF@name@dp@adjust+\CF@dp@max-\CF@dp@stuffbox\fi\relax
		\CF@parse@molname#3\\\@nil
	}%
}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%           S C H É M A S      R É A C T I O N N E L S           %%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\let\CF@scheme@nest\z@

\def\CF@subscheme{\CF@testopt\CF@subscheme@a{}}
\def\CF@subscheme@a[#1]{\CF@testopt{\CF@subscheme@b[#1]}{text}}
\def\CF@subscheme@b[#1][#2]#3{\schemestart[#1][#2]#3\schemestop}

\def\chemleft#1#2\chemright#3{%
	\leavevmode
	\begingroup
		\setbox\z@\hbox{$\vcenter{\hbox{}}$}\edef\CF@delim@math@ht{\the\ht\z@}%
		\setbox\z@\hbox{#2}\edef\CF@delim@dim{\the\dimexpr(\ht\z@+\dp\z@)/\tw@}%
		\edef\CF@delim@shift{\the\dimexpr(\ht\z@-\dp\z@)/\tw@-\CF@delim@math@ht}%
		\raise\CF@delim@shift\hbox{$\left#1\vrule height\CF@delim@dim depth\CF@delim@dim width\z@\right.$}\box\z@
		\raise\CF@delim@shift\hbox{$\left.\vrule height\CF@delim@dim depth\CF@delim@dim width\z@\right#3$}%
	\endgroup
}

\def\chemright#1{%
	\immediate\write-1{Package \CFname\space Warning: "\string\chemright\string#1"ignored! No \string\chemleft\space previously found.^^J}%
}

\def\chemup#1#2\chemdown#3{%
	\begingroup
		\setbox\z@\hbox{\printatom{#2}}\edef\CF@delim@dim{\the\dimexpr\wd\z@/\tw@}%
		\tikzpicture[every node/.style={inner sep=\z@,outer sep=\z@,minimum size=\z@},baseline]%
			\node[anchor=base west](chem@stuff){\box\z@};%
			\node[at=(chem@stuff.north),anchor=east,rotate=-90]{$\left#1\vrule height\CF@delim@dim depth\CF@delim@dim width\z@\right.$};%
			\node[at=(chem@stuff.south),anchor=west,rotate=-90]{$\left.\vrule height\CF@delim@dim depth\CF@delim@dim width\z@\right#3$};%
		\endtikzpicture
	\endgroup
}

\def\chemdown#1{%
	\immediate\write-1{Package \CFname\space Warning: "\string\chemdown\string#1" ignored! No \string\chemup\space previously found.^^J}%
}

\def\CF@set@style#1,#2,#3\@nil#4#5#6{%
	\def#4{#1}\let#5\empty\let#6\empty
	\CF@if@firsttokmatch\CF@quark{#2\relax}
		{}%
		{\def#5{#2}%
		\CF@if@firsttokmatch\CF@quark{#3\relax}
			{}%
			{\CF@set@style@a#3\@nil#6}%
		}%
}
\def\CF@set@style@a#1,\CF@quark#2\@nil#3{\def#3{#1}}

\def\CF@and{\futurelet\CF@toks@a\CF@and@a}

\def\CF@and@a{%
	\CF@ifx\CF@toks@a\bgroup
		\CF@and@b
		{\CF@and@b{}}%
}

\def\CF@and@b#1{%
	\CF@set@style#1,\CF@quark,\CF@quark\@nil\CF@signspace@ante\CF@signspace@post\CF@sign@vshift
	\CF@doifempty\CF@signspace@ante{\CF@valuetomacro\CF@signspace@ante[0.5em]{+ sep left}}%
	\CF@doifempty\CF@signspace@post{\CF@valuetomacro\CF@signspace@post[0.5em]{+ sep right}}%
	\CF@doifempty\CF@sign@vshift{\CF@valuetomacro\CF@sign@vshift[0pt]{+ vshift}}%
	\raise\CF@sign@vshift\hbox{\kern\CF@signspace@ante$+$\kern\CF@signspace@post}%
}

\def\schemestart{%
	\xdef\CF@scheme@nest{\number\numexpr\CF@scheme@nest+\@ne}%
	\CF@testopt\CF@schemestart@a{}%
}

\def\CF@schemestart@a[#1]{%
	\CF@valuetomacro\default@compound@style[]{compound style}%
	\CF@set@style#1,\CF@quark,\CF@quark\@nil\CF@arrow@angle\CF@arrow@length\CF@arrow@style
	\CF@doifempty\CF@arrow@angle{\CF@valuetomacro\CF@arrow@angle[0]{arrow angle}}%
	\CF@doifempty\CF@arrow@length{\CF@valuetomacro\CF@arrow@length[1]{arrow coeff}}%
	\CF@valuetomacro\CF@default@arrow@style[]{arrow style}%
	\CF@valuetomacro\CF@arrow@offset[1em]{arrow offset}%
	\CF@valuetomacro\CF@compound@sep[5em]{compound sep}%
	\CF@valuetomacro\CF@arrow@labelsep[3pt]{arrow label sep}%
	\CF@eexp@second{\CF@preadd@tocs\CF@default@arrow@style}{\useKV[chemfig]{arrow head},}%
	\CF@ifx\empty\CF@arrow@style
		{\let\CF@arrow@style\CF@default@arrow@style}
		{\CF@exp@second{\CF@preadd@tocs\CF@arrow@style}{\CF@default@arrow@style,}}% se rajoute après le style par défaut
	\CF@valuetomacro\CF@arrow@double@sep[2pt]{arrow double sep}%
	\pgfmathsetmacro\CF@arrow@double@sep{\CF@arrow@double@sep/2}%
	\CF@valuetomacro\CF@arrow@double@pos@start[0.6]{arrow double coeff}%
	\pgfmathsetmacro\CF@arrow@double@pos@start{(1-\CF@arrow@double@pos@start)/2}%
	\pgfmathsetmacro\CF@arrow@double@pos@end{1-\CF@arrow@double@pos@start}%
	\ifboolKV[chemfig]{scheme debug}
		{\tikzpicture[every node/.style={draw,anchor=base,inner sep=\z@,outer sep=\z@,minimum size=1.5pt},baseline,remember picture]%
		}
		{\tikzpicture[every node/.style={anchor=base,inner sep=\z@,outer sep=\z@,minimum size=\z@},baseline,remember picture]%
		}%
	\let\merge\CF@merge
	\expandafter\let\csname+\endcsname\CF@and
	\let\arrow\CF@arrow
	\let\schemestop\CF@schemestop
	\let\subscheme\CF@subscheme
	\CF@testopt{\CF@schemestart@b[#1]}{text}%
}

\def\CF@schemestart@b[#1][#2]{%
	\ifnum\CF@scheme@nest=\@ne% la commande n'est pas imbriquée ?
		\CF@compound@cnt\z@
	\fi
	\edef\CF@current@nodename{c\number\CF@compound@cnt}%
	\let\CF@next@nodename\empty
	\let\CF@next@nodestyle\empty
	\let\CF@direct@arrow@list\empty
	\ifboolKV[chemfig]{scheme debug}
		{\node[fill,green](\CF@current@nodename){};}
		{\node(\CF@current@nodename){};}%
	\def\CF@next@nodeanchor{#2}%
	\CF@doifempty\CF@next@nodeanchor{\def\CF@next@nodeanchor{text}}%
	\let\CF@compound\empty
	\CF@schemestart@c
}

\def\CF@schemestart@c{%
	\futurelet\CF@toks@a\CF@schemestart@e
}

\expandafter\def\expandafter\CF@schemestart@d\space{\futurelet\CF@toks@a\CF@schemestart@e}

\def\CF@schemestart@e{% ... et l'examine :
	\CF@if@firsttokin@a{\arrow\schemestop\merge}%
		{}
		{\CF@ifx\CF@toks@a\bgroup
			{\CF@add@nextarg}
			{\CF@ifx\CF@toks@a\@sptoken
				{\CF@add@tocs\CF@compound{ }%
				\CF@schemestart@d
				}
				{\afterassignment\CF@schemestart@c
				\CF@add@tocs\CF@compound
				}%
			}%
		}%
}

\def\CF@add@nextarg#1{\CF@add@tocs\CF@compound{{#1}}\CF@schemestart@c}

\def\CF@display@compound#1#2{% #1 = nom et #2 = style
	\CF@doifnotempty\CF@compound
		{\global\advance\CF@compound@cnt\@ne
		\CF@ifx\default@compound@style\empty
			{\let\CF@current@nodestyle\empty}
			{\CF@exp@second{\def\CF@current@nodestyle}{\default@compound@style,}}%
		\CF@add@tocs\CF@current@nodestyle{anchor=\CF@next@nodeanchor,at=(\CF@current@nodename)}%
		\CF@ifempty{#2}%
			{\CF@doifnotempty\CF@next@nodestyle
				{\CF@eadd@tocs\CF@current@nodestyle{\expandafter,\CF@next@nodestyle}}%
			}
			{\CF@doifnotempty\CF@next@nodestyle
				{\immediate\write-1{Package \CFname\space Warning: two styles for the same node, first style "\CF@next@nodestyle" ignored^^J}%
				}%
			\CF@add@tocs\CF@current@nodestyle{,#2}%
			}%
		\CF@ifempty{#1}
			{\edef\CF@tmp@str{\CF@ifempty\CF@next@nodename{c\number\CF@compound@cnt}{\CF@next@nodename}}%
			}
			{\CF@doifnotempty\CF@next@nodename
				{\immediate\write-1{Package \CFname\space Warning: two names for the same node, first name "\CF@next@nodename" ignored^^J}%
				}%
			\edef\CF@tmp@str{#1}%
			}%
		\expandafter\node\expandafter[\CF@current@nodestyle](\CF@tmp@str){\CF@compound};%
		\ifboolKV[chemfig]{scheme debug}%
			{\node[draw=none,anchor=270,at=(\CF@tmp@str.90),fill=green!60,overlay,opacity=0.5]{\scriptsize\bfseries\CF@tmp@str};%
			}
			{}%
		\let\CF@current@nodename\CF@tmp@str
		}%
}

\def\CF@schemestop{%
	\CF@display@compound{}{}%
	\CF@direct@arrow@list
	\endtikzpicture
	\xdef\CF@scheme@nest{\number\numexpr\CF@scheme@nest-\@ne}%
}

\def\CF@analyse@arrowarg#1{\CF@analyse@arrowarg@i#1[]\@nil}

\def\CF@analyse@arrowarg@i#1[#2]#3\@nil{%
	\CF@if@instr{#1}.{\CF@add@tocs\CF@tmp@str{#1[#2]}}{\CF@add@tocs\CF@tmp@str{#1.[#2]}}%
}

\def\CF@arrow{%
	\CF@ifnextchar(%
		\CF@arrow@a
		{\CF@ifnextchar\bgroup{\CF@arrow@b(.[]--.[])}{\CF@arrow@b(.[]--.[]){}}}%
}

\def\CF@arrow@a(#1--#2){%
	\def\CF@tmp@str{(}%
	\CF@analyse@arrowarg{#1}%
	\CF@add@tocs\CF@tmp@str{--}%
	\CF@analyse@arrowarg{#2}%
	\CF@add@tocs\CF@tmp@str)%
	\CF@ifnextchar\bgroup{\expandafter\CF@arrow@b\CF@tmp@str}{\expandafter\CF@arrow@b\CF@tmp@str{}}%
}

\def\CF@arrow@b(#1.#2[#3]--#4.#5[#6])#7{%
	\def\CF@current@arrowtype{#7}% nom de la flèche
	\CF@doifempty\CF@current@arrowtype{\def\CF@current@arrowtype{->}}%
	\CF@testopt{\CF@arrow@c(#1.#2[#3]--#4.#5[#6])}{}%
}

\def\CF@arrow@c(#1.#2[#3]--#4.#5[#6])[#7]{%
	\def\CF@tmp@str{\CF@arrow@e(#1.#2[#3]--#4.#5[#6])}%
	\CF@arrow@d#7,\empty,\empty\@nil
}

\def\CF@arrow@d#1,#2,#3\@nil{%
	\CF@add@tocs\CF@tmp@str{{#1}}%
	\CF@eadd@tocs\CF@tmp@str{\expandafter{#2}}%
	\expandafter\CF@eadd@tocs\expandafter\CF@tmp@str\expandafter{\expandafter\expandafter\expandafter{\expandafter\CF@sanitize@lastitem#3,\empty\@nil}}%
	\CF@tmp@str
}

% #1, #4 : nom des nodes    #2, #5 : ancres des nodes    #3, #6 : styles des nodes
% #7 : angle flèche    #8 : longueur flèche    #9 : style tikz de la flèche
\def\CF@arrow@e(#1.#2[#3]--#4.#5[#6])#7#8#9{%
	\let\CF@arrow@current@style\CF@arrow@style
	\if\CF@arobas\expandafter\CF@firsttonil\detokenize{#1.}\@nil% si #1 commence par @
		\if\CF@arobas\expandafter\CF@firsttonil\detokenize{#4.}\@nil
			\CF@eadd@tocs\CF@direct@arrow@list{\expandafter\CF@direct@arrow\expandafter{\CF@current@arrowtype}{#1}{#2}{#4}{#5}{#9}}%
			\let\CF@next@action\CF@schemestart@c
		\else
			\CF@doifnotempty\CF@arrow@current@style{\CF@add@tocs\CF@arrow@current@style,}%
			\CF@doifnotempty{#9}{\CF@add@tocs\CF@arrow@current@style{#9,}}%
			\CF@display@compound{}{#3}%
			\def\CF@next@nodename{#4}%
			\CF@exp@second{\def\CF@current@nodename}{\CF@gobarg#1}%
			\let\CF@arrow@start@name\CF@current@nodename
			\let\CF@arrow@end@name\CF@next@nodename
			\CF@arrow@f{#7}{#8}{#2}{#5}%
			\def\CF@next@nodestyle{#6}%
		\fi
	\else
		\CF@doifnotempty\CF@arrow@current@style{\CF@add@tocs\CF@arrow@current@style,}%
		\CF@doifnotempty{#9}{\CF@add@tocs\CF@arrow@current@style{#9,}}%
		\if\CF@arobas\expandafter\CF@firsttonil\detokenize{#2.}\@nil
			\errmessage{Package \CFname\space Error: syntax "(<name>--@<name>)" is not allowed}%
		\else
			\CF@display@compound{#1}{#3}%
			\edef\CF@arrow@start@name{\CF@ifempty{#1}\CF@current@nodename{#1}\CF@doifnotempty{#2}{.#2}}%
			\CF@arrow@f{#7}{#8}{#2}{#5}%
			\def\CF@next@nodename{#4}%
			\def\CF@next@nodestyle{#6}%
		\fi
	\fi
	\CF@arrow@gobspaces% mange les espaces puis exécute \CF@next@action
}

\def\CF@arrow@gobspaces{\futurelet\CF@toks@a\CF@arrow@gobspaces@a}

\def\CF@arrow@gobspaces@a{%
	\CF@ifx\@sptoken\CF@toks@a
		\CF@arrow@gobspaces@b
		\CF@next@action
}

\expandafter\def\expandafter\CF@arrow@gobspaces@b\space{\futurelet\CF@toks@a\CF@arrow@gobspaces@a}

\def\CF@arrow@f#1#2#3#4{% #1=angle   #2=longueur    #3=ancre départ   #4=ancre arrivée
	\def\CF@next@action{\let\CF@compound\empty\CF@schemestart@c}%
	\def\CF@arrow@current@angle{#1}\CF@doifempty\CF@arrow@current@angle{\let\CF@arrow@current@angle\CF@arrow@angle}%
	\def\CF@current@arrow@length{#2}\CF@doifempty\CF@current@arrow@length{\let\CF@current@arrow@length\CF@arrow@length}%
	\node[at=(\CF@current@nodename.\CF@ifempty{#3}\CF@arrow@current@angle{#3}),shift=(\CF@arrow@current@angle:\CF@current@arrow@length*\CF@compound@sep),cyan,fill](end@arrow@i@\number\CF@scheme@nest){};%
	\edef\CF@arrow@end@name{end@arrow@i@\number\CF@scheme@nest\CF@doifnotempty{#4}{.#4}}%
	\ifboolKV[chemfig]{scheme debug}
		{\node[at=(\CF@current@nodename.\CF@ifempty{#3}\CF@arrow@current@angle{#3}),shift=(\CF@arrow@current@angle:\CF@arrow@offset),red,fill](start@arrow){};%
		\node[at=(\CF@current@nodename.\CF@ifempty{#3}\CF@arrow@current@angle{#3}),shift=(\CF@arrow@current@angle:\CF@current@arrow@length*\CF@compound@sep-\CF@arrow@offset),red,fill](end@arrow){};%
		}
		{\node[at=(\CF@current@nodename.\CF@ifempty{#3}\CF@arrow@current@angle{#3}),shift=(\CF@arrow@current@angle:\CF@arrow@offset)](start@arrow){};%
		\node[at=(\CF@current@nodename.\CF@ifempty{#3}\CF@arrow@current@angle{#3}),shift=(\CF@arrow@current@angle:\CF@current@arrow@length*\CF@compound@sep-\CF@arrow@offset)](end@arrow){};%
		}%
	\def\CF@arrow@start@node{start@arrow}\def\CF@arrow@end@node{end@arrow}%
	\csname\expandafter\CF@grab@arrow@name\CF@current@arrowtype[\@nil\CF@three@ea\endcsname
		\expandafter\CF@grab@arrow@args\CF@current@arrowtype[]\@nil[][][][][][][][]\@nil
	\def\CF@current@nodename{end@arrow@i@\number\CF@scheme@nest}%
	\edef\CF@next@nodeanchor{\CF@ifempty{#4}{180+\CF@arrow@current@angle}{#4}}%
}

% trace un flèche initiée par (@nom--@nom)
% #1=type de flèche   #2=nom depart   #3=ancre départ    #4=nom arrivée    #5=ancre arrivée    #6=style flèche
\def\CF@direct@arrow#1#2#3#4#5#6{%
	\CF@exp@second{\def\CF@arrow@start@name}{\CF@gobarg#2}%
	\CF@exp@second{\def\CF@arrow@end@name}{\CF@gobarg#4}%
	\path[sloped,allow upside down](\CF@gobarg#2\ifx\empty#3\empty\else.#3\fi)--(\CF@gobarg#4\ifx\empty#5\empty\else.#5\fi)%
		coordinate[pos=0,xshift=\CF@arrow@offset](start@direct@arrow)%
		coordinate[pos=1,xshift=-\CF@arrow@offset](end@direct@arrow);%
	\def\CF@arrow@start@node{start@direct@arrow}%
	\def\CF@arrow@end@node{end@direct@arrow}%
	\pgfmathanglebetweenpoints
		{\pgfpointanchor{\CF@gobarg#2}{\ifx\empty#3\empty center\else#3\fi}}% Ne pas utiliser \CF@ifempty ici !!!
		{\pgfpointanchor{\CF@gobarg#4}{\ifx\empty#5\empty center\else#5\fi}}%
	\let\CF@arrow@current@angle\pgfmathresult
	\CF@doifnotempty{#6}{\CF@add@tocs\CF@arrow@current@style{#6,}}%
	\csname\CF@grab@arrow@name#1[]\@nil\expandafter\endcsname\CF@grab@arrow@args#1[]\@nil[][][][][][][][]\@nil
}

\def\CF@merge@grab@chardir#1[#2][#3]#4\@nil{%
	\expandafter\futurelet\expandafter\CF@toks@a\expandafter\CF@gobtonil\CF@firsttonil#1>\@nil\@nil
	\ifx>\CF@toks@a\def\CF@merge@angle{0}\def\CF@merge@extreme{xmax}\def\CF@merge@sign{+}\else
	\ifx<\CF@toks@a\def\CF@merge@angle{180}\def\CF@merge@extreme{xmin}\def\CF@merge@sign{-}\else
	\ifx^\CF@toks@a\def\CF@merge@angle{90}\def\CF@merge@extreme{ymax}\def\CF@merge@sign{+}\else
	\ifx v\CF@toks@a\def\CF@merge@angle{-90}\def\CF@merge@extreme{ymin}\def\CF@merge@sign{-}%
	\fi\fi\fi\fi
	\def\CF@merge@labelup{#2}\def\CF@merge@labeldo{#3}%
}

\def\CF@merge#1({%
	\CF@merge@grab@chardir#1[][]\@nil
	\CF@merge@a(%
}

\def\CF@merge@a#1--(#2){\CF@testopt{\CF@merge@b#1--(#2)}{}}

\def\CF@merge@b#1--(#2)[#3]{%
	\CF@display@compound{}{}%
	\CF@parse@mergeopt#3,\CF@quark,\CF@quark,\CF@quark\@nil
	\def\CF@merge@xmax{-16383.99999pt}\let\CF@merge@ymax\CF@merge@xmax
	\def\CF@merge@xmin{16383.99999pt}\let\CF@merge@ymin\CF@merge@xmin
	\CF@merge@parse@nodelist#1(\relax)% calcule les maxi des positions
	\pgfmathsetmacro\CF@merge@extreme@result{\csname CF@merge@\CF@merge@extreme\endcsname\CF@merge@sign\CF@merge@fromcoeff*\CF@compound@sep}%
	\CF@merge@c#1(\relax)% trace les lignes entre les noeuds précédents et la ligne de jonction
	\CF@exp@second{\def\CF@tmp@str}{\expandafter[\CF@merge@style,shorten <=0,shorten >=0,-]}%
	\if x\expandafter\CF@firsttonil\CF@merge@extreme\@nil
		\CF@add@tocs\CF@tmp@str{(\CF@merge@extreme@result pt,\CF@merge@ymax)--(\CF@merge@extreme@result pt,\CF@merge@ymin)}%
	\else
		\CF@add@tocs\CF@tmp@str{(\CF@merge@xmin,\CF@merge@extreme@result pt)--(\CF@merge@xmax,\CF@merge@extreme@result pt)}%
	\fi
	\expandafter\draw\CF@tmp@str node[pos=\CF@merge@splitcoeff](merge@point){}% trace la ligne de jonction
		node[at=(merge@point),shift=(\CF@merge@angle:\CF@compound@sep*\CF@merge@tocoeff-\CF@arrow@offset)](end@merge){}%
		node[at=(merge@point),shift=(\CF@merge@angle:\CF@compound@sep*\CF@merge@tocoeff)](end@merge@i){};%
	\let\CF@arrow@current@angle\CF@merge@angle
	\expandafter\draw\expandafter[\CF@merge@style,shorten <=0](merge@point)--(end@merge)%
		\expandafter\CF@arrow@display@label@a\expandafter{\CF@merge@labelup}{.5}+\expandafter\CF@arrow@display@label@a\expandafter{\CF@merge@labeldo}{.5}-;%
	\def\CF@current@nodename{end@merge@i}%
	\let\CF@tmp@str\empty
	\CF@analyse@arrowarg{#2}%
	\expandafter\CF@merge@d\CF@tmp@str\@nil
}

\def\CF@merge@c(#1){%
	\if\relax\expandafter\noexpand\CF@firsttonil#1\@nil
	\else
		\CF@if@stop{#1}%
			{\edef\merge@current@nodename{\CF@before@stop#1\@nil}\edef\merge@current@anchor{\CF@after@stop#1\@nil}}%
			{\def\merge@current@nodename{#1}\let\merge@current@anchor\CF@merge@angle}%
		\if x\expandafter\CF@firsttonil\CF@merge@extreme\@nil
			\pgfextracty\CF@dim{\pgfpointanchor\merge@current@nodename\merge@current@anchor}%
			\expandafter\draw\expandafter[\CF@merge@style,shorten >=0,-]([shift=(\CF@merge@angle:\CF@arrow@offset)]\merge@current@nodename.\merge@current@anchor)--(\CF@merge@extreme@result pt,\CF@dim);%
		\else
			\pgfextractx\CF@dim{\pgfpointanchor\merge@current@nodename\merge@current@anchor}%
			\expandafter\draw\expandafter[\CF@merge@style,shorten >=0,-]([shift=(\CF@merge@angle:\CF@arrow@offset)]\merge@current@nodename.\merge@current@anchor)--(\CF@dim,\CF@merge@extreme@result pt);%
		\fi
		\expandafter\CF@merge@c
	\fi
}

\def\CF@merge@d#1.#2[#3]\@nil{%
	\def\CF@next@nodename{#1}%
	\edef\CF@next@nodeanchor{\CF@ifempty{#2}{180+\CF@merge@angle}{#2}}%
	\def\CF@next@nodestyle{#3}%
	\let\CF@compound\empty
	\CF@schemestart@c
}

\def\CF@parse@mergeopt#1,#2,#3,#4\@nil{%
	\CF@ifempty{#1}{\def\CF@merge@fromcoeff{0.5}}{\def\CF@merge@fromcoeff{#1}}%
	\def\CF@merge@tocoeff{0.5}%
	\def\CF@merge@splitcoeff{0.5}%
	\CF@eexp@second{\def\CF@merge@style}{\useKV[chemfig]{arrow head}}%
	\CF@if@firsttokmatch\CF@quark{#2\relax}
		{}
		{\CF@ifempty{#2}{\def\CF@merge@tocoeff{0.5}}{\def\CF@merge@tocoeff{#2}}%
		\CF@if@firsttokmatch\CF@quark{#3\relax}
			{}
			{\CF@ifempty{#3}{\def\CF@merge@splitcoeff{0.5}}{\def\CF@merge@splitcoeff{#3}}%
			\CF@if@firsttokmatch\CF@quark{#4\relax}
				{}
				{\CF@parse@mergeopt@i#4\@nil}%
			}%
		}%
}

\def\CF@parse@mergeopt@i#1,\CF@quark#2\@nil{%
	\CF@ifempty{#1}{}{\CF@add@tocs\CF@merge@style{,#1}}%
}

\def\CF@merge@parse@nodelist(#1){%
	\if\relax\expandafter\noexpand\CF@firsttonil#1\@nil
	\else
		\CF@if@stop{#1}%
			{\edef\merge@current@nodename{\CF@before@stop#1\@nil}\edef\merge@current@anchor{\CF@after@stop#1\@nil}}%
			{\def\merge@current@nodename{#1}\let\merge@current@anchor\CF@merge@angle}%
		\pgfextractx\CF@dim{\pgfpointanchor\merge@current@nodename\merge@current@anchor}%
		\ifdim\CF@dim>\CF@merge@xmax\edef\CF@merge@xmax{\the\CF@dim}\fi
		\ifdim\CF@dim<\CF@merge@xmin\edef\CF@merge@xmin{\the\CF@dim}\fi
		\pgfextracty\CF@dim{\pgfpointanchor\merge@current@nodename\merge@current@anchor}%
		\ifdim\CF@dim>\CF@merge@ymax\edef\CF@merge@ymax{\the\CF@dim}\fi
		\ifdim\CF@dim<\CF@merge@ymin\edef\CF@merge@ymin{\the\CF@dim}\fi
		\expandafter\CF@merge@parse@nodelist
	\fi
}

\def\CF@grab@arrow@name#1[#2\@nil{\detokenize{CF@arrow(#1)}}
\def\CF@grab@arrow@args#1[#2\@nil{[#2}

\def\CF@make@parameter@text#1{%
	\toks\z@{}%
	\CF@cnt@groupnumber#1\relax
	\CF@make@parameter@text@a1%
}

\def\CF@make@parameter@text@a#1{%
	\unless\ifnum#1>\CF@cnt@groupnumber
		\toks\z@\expandafter{\the\toks\z@[###1]}%
		\expandafter\CF@make@parameter@text@a\expandafter{\number\numexpr#1+1\expandafter}%
	\fi
}

% #1 est le nombre d'arguments optionnels, #2 est le nom et #3 le code
\def\definearrow#1#2#3{%
	\begingroup
		\CF@make@parameter@text{#1}%
	\expandafter\endgroup
	\expandafter\def\csname\detokenize{CF@arrow(#2)}\expandafter\endcsname\the\toks\z@{#3\CF@gobtonil}%
}

\def\CF@if@stop#1{\CF@if@stop@a#1.\@nil}
\def\CF@if@stop@a#1.#2\@nil{\ifx\empty#2\empty\expandafter\CF@execsecond\else\expandafter\CF@execfirst\fi}
\def\CF@before@stop#1.#2\@nil{#1}
\def\CF@after@stop#1.#2\@nil{#2}

\def\CF@rotate@node*#1#2\@nil{\CF@if@stop{#1}{\CF@before@stop#1\@nil}{#1}}
\def\CF@anchor@node*#1#2\@nil#3{\CF@if@stop{#1}{\CF@after@stop#1\@nil}{\CF@arrow@current@angle-#390-#1}}

% #1 = label  #2 = position  #3 = + ou - (au dessus ou au dessous)  #4 : nom du noeud de départ
% #5 = label  #6 = position  #7 = + ou - (au dessus ou au dessous)  #8 : nom du noeud de fin
\def\CF@arrow@display@label#1#2#3#4#5#6#7#8{%
	\CF@doifnotempty{#1#5}
		{\path(#4)--(#8)\CF@arrow@display@label@a{#1}{#2}{#3}\CF@arrow@display@label@a{#5}{#6}{#7};}%
}

\def\CF@arrow@display@label@a#1#2#3{%
	\CF@doifnotempty{#1}
		{\if*\expandafter\CF@firsttonil\detokenize{#1}\@nil
			\ifboolKV[chemfig]{scheme debug}
				{node[pos=#2,sloped,yshift=#3\CF@arrow@labelsep,draw,fill,cyan](shifted@node){}%
				node[draw,rotate=\CF@rotate@node#1\@nil,anchor=\CF@anchor@node#1\@nil#3,at=(shifted@node)]{\expandafter\CF@gobarg\CF@gobarg#1}%
				}
				{node[pos=#2,sloped,yshift=#3\CF@arrow@labelsep](shifted@node){}%
				node[rotate=\CF@rotate@node#1\@nil,anchor=\CF@anchor@node#1\@nil#3,at=(shifted@node)]{\expandafter\CF@gobarg\CF@gobarg#1}%
				}%
		\else
			\ifboolKV[chemfig]{scheme debug}
				{node[pos=#2,sloped,yshift=#3\CF@arrow@labelsep,draw,fill,cyan](shifted@node){}%
				node[draw,pos=#2,anchor=-#390,sloped,yshift=#3\CF@arrow@labelsep]{#1}%
				}
				{node[pos=#2,anchor=-#390,sloped,yshift=#3\CF@arrow@labelsep]{#1}%
				}
		\fi
		}%
}

% pose des noeuds décalés de la dimension #1 à (\CF@arrow@start@node) et (\CF@arrow@end@node)
\def\CF@arrow@shift@nodes#1{%
	\unless\ifdim\CF@ifempty{#1}\z@{#1}=\z@
		\edef\CF@tmp@str{%
			\noexpand\path(\CF@arrow@start@node)--(\CF@arrow@end@node)%
			node[pos=0,sloped,yshift=#1](\CF@arrow@start@node1){}node[pos=1,sloped,yshift=#1](\CF@arrow@end@node1){};}%
		\CF@tmp@str
		\edef\CF@arrow@start@node{\CF@arrow@start@node1}\edef\CF@arrow@end@node{\CF@arrow@end@node1}%
	\fi
}

\definearrow3{->}{%
	\CF@arrow@shift@nodes{#3}%
	\expandafter\draw\expandafter[\CF@arrow@current@style](\CF@arrow@start@node)--(\CF@arrow@end@node);%
	\CF@arrow@display@label{#1}{0.5}+\CF@arrow@start@node{#2}{0.5}-\CF@arrow@end@node
}

\definearrow3{<-}{%
	\CF@arrow@shift@nodes{#3}%
	\expandafter\draw\expandafter[\CF@arrow@current@style](\CF@arrow@end@node)--(\CF@arrow@start@node);%
	\CF@arrow@display@label{#1}{0.5}+\CF@arrow@start@node{#2}{0.5}-\CF@arrow@end@node
}

\definearrow5{-/>}{%
	\CF@arrow@shift@nodes{#3}%
	\expandafter\draw\expandafter[\CF@arrow@current@style](\CF@arrow@start@node)--(\CF@arrow@end@node)%
		coordinate[midway,shift=(\CF@arrow@current@angle:-1pt)](midway@i)%
		coordinate[midway,shift=(\CF@arrow@current@angle:1pt)](midway@ii)%
		coordinate[at=(midway@i),shift=(\CF@ifempty{#4}{225}{#4+180}+\CF@arrow@current@angle:\CF@ifempty{#5}{5pt}{#5})](line@start)%
		coordinate[at=(midway@i),shift=(\CF@ifempty{#4}{45}{#4}+\CF@arrow@current@angle:\CF@ifempty{#5}{5pt}{#5})](line@end)%
		coordinate[at=(midway@ii),shift=(\CF@ifempty{#4}{225}{#4+180}+\CF@arrow@current@angle:\CF@ifempty{#5}{5pt}{#5})](line@start@i)%
		coordinate[at=(midway@ii),shift=(\CF@ifempty{#4}{45}{#4}+\CF@arrow@current@angle:\CF@ifempty{#5}{5pt}{#5})](line@end@i);
	\draw(line@start)--(line@end);%
	\draw(line@start@i)--(line@end@i);%
	\CF@arrow@display@label{#1}{0.5}+\CF@arrow@start@node{#2}{0.5}-\CF@arrow@end@node
}

\definearrow3{<->}{%
	\CF@arrow@shift@nodes{#3}%
	\path(\CF@arrow@start@node)--(\CF@arrow@end@node)%
			node[pos=0.5,sloped,xshift=-1pt](\CF@arrow@start@node1){}node[pos=0.5,sloped,xshift=1pt](\CF@arrow@end@node1){};%
	\expandafter\draw\expandafter[\CF@arrow@current@style](\CF@arrow@start@node1)--(\CF@arrow@end@node);%
	\expandafter\draw\expandafter[\CF@arrow@current@style](\CF@arrow@end@node1)--(\CF@arrow@start@node);%
	\CF@arrow@display@label{#1}{0.5}+\CF@arrow@start@node{#2}{0.5}-\CF@arrow@end@node
}

\definearrow3{<=>}{%
	\CF@arrow@shift@nodes{#3}%
	\path[allow upside down](\CF@arrow@start@node)--(\CF@arrow@end@node)%
			node[pos=0,sloped,yshift=\CF@arrow@double@sep](\CF@arrow@start@node @u0){}%
			node[pos=0,sloped,yshift=-\CF@arrow@double@sep](\CF@arrow@start@node @d0){}%
			node[pos=1,sloped,yshift=\CF@arrow@double@sep](\CF@arrow@start@node @u1){}%
			node[pos=1,sloped,yshift=-\CF@arrow@double@sep](\CF@arrow@start@node @d1){};%
	\begingroup
		\ifboolKV[chemfig]{arrow double harpoon}{\pgfarrowharpoontrue}{}%
		\expandafter\draw\expandafter[\CF@arrow@current@style](\CF@arrow@start@node @u0)--(\CF@arrow@start@node @u1);%
		\expandafter\draw\expandafter[\CF@arrow@current@style](\CF@arrow@start@node @d1)--(\CF@arrow@start@node @d0);%
	\endgroup
	\CF@arrow@display@label{#1}{0.5}+\CF@arrow@start@node{#2}{0.5}-\CF@arrow@end@node%
}

\definearrow3{<->>}{%
	\CF@arrow@shift@nodes{#3}%
	\path[allow upside down](\CF@arrow@start@node)--(\CF@arrow@end@node)%
			node[pos=0,sloped,yshift=1pt](\CF@arrow@start@node @u0){}%
			node[pos=\CF@arrow@double@pos@start,sloped,yshift=-1pt](\CF@arrow@start@node @d0){}%
			node[pos=1,sloped,yshift=1pt](\CF@arrow@start@node @u1){}%
			node[pos=\CF@arrow@double@pos@end,sloped,yshift=-1pt](\CF@arrow@start@node @d1){};%
	\begingroup
		\ifboolKV[chemfig]{arrow double harpoon}{\pgfarrowharpoontrue}{}%
		\expandafter\draw\expandafter[\CF@arrow@current@style](\CF@arrow@start@node @u0)--(\CF@arrow@start@node @u1);%
		\expandafter\draw\expandafter[\CF@arrow@current@style](\CF@arrow@start@node @d1)--(\CF@arrow@start@node @d0);%
	\endgroup
	\CF@arrow@display@label{#1}{0.5}+\CF@arrow@start@node{#2}{0.5}-\CF@arrow@end@node%
}

\definearrow3{<<->}{%
	\path[allow upside down](\CF@arrow@start@node)--(\CF@arrow@end@node)%
			node[pos=\CF@arrow@double@pos@start,sloped,yshift=1pt](\CF@arrow@start@node @u0){}%
			node[pos=0,sloped,yshift=-1pt](\CF@arrow@start@node @d0){}%
			node[pos=\CF@arrow@double@pos@end,sloped,yshift=1pt](\CF@arrow@start@node @u1){}%
			node[pos=1,sloped,yshift=-1pt](\CF@arrow@start@node @d1){};%
	\begingroup
		\ifboolKV[chemfig]{arrow double harpoon}{\pgfarrowharpoontrue}{}%
		\expandafter\draw\expandafter[\CF@arrow@current@style](\CF@arrow@start@node @u0)--(\CF@arrow@start@node @u1);%
		\expandafter\draw\expandafter[\CF@arrow@current@style](\CF@arrow@start@node @d1)--(\CF@arrow@start@node @d0);%
	\endgroup
	\CF@arrow@display@label{#1}{0.5}+\CF@arrow@start@node{#2}{0.5}-\CF@arrow@end@node
}

\definearrow30{%
	\CF@arrow@shift@nodes{#3}%
	\CF@arrow@display@label{#1}{0.5}+\CF@arrow@start@node{#2}{0.5}-\CF@arrow@end@node
}

\definearrow5{-U>}{%
	\CF@arrow@shift@nodes{#3}%
	\expandafter\draw\expandafter[\CF@arrow@current@style](\CF@arrow@start@node)--(\CF@arrow@end@node)node[midway](Uarrow@arctangent){};%
	\CF@ifempty{#4}
		{\def\CF@Uarrow@radius{0.333}}
		{\def\CF@Uarrow@radius{#4}}%
	\CF@ifempty{#5}%
		{\def\CF@Uarrow@absangle{60}}
		{\pgfmathsetmacro\CF@Uarrow@absangle{abs(#5)}}% ne prendre en compte que la valeur absolue de l'angle
	\edef\CF@tmp@str{[\CF@ifempty{#1}{draw=none}{\unexpanded\expandafter{\CF@arrow@current@style}},-]}%
	\expandafter\draw\CF@tmp@str (Uarrow@arctangent)%
		arc[radius=\CF@compound@sep*\CF@current@arrow@length*\CF@Uarrow@radius,start angle=\CF@arrow@current@angle-90,delta angle=-\CF@Uarrow@absangle]node(Uarrow@start){};
	\edef\CF@tmp@str{[\CF@ifempty{#2}{draw=none}{\unexpanded\expandafter{\CF@arrow@current@style}}]}%
	\expandafter\draw\CF@tmp@str (Uarrow@arctangent)%
		arc[radius=\CF@compound@sep*\CF@current@arrow@length*\CF@Uarrow@radius,start angle=\CF@arrow@current@angle-90,delta angle=\CF@Uarrow@absangle]node(Uarrow@end){};
	\pgfmathsetmacro\CF@tmp@str{\CF@Uarrow@radius*cos(\CF@arrow@current@angle)<0?"-":"+"}%
	\ifdim\CF@Uarrow@radius pt>\z@
		\CF@arrow@display@label{#1}{0}\CF@tmp@str{Uarrow@start}{#2}{1}\CF@tmp@str{Uarrow@end}%
	\else
		\CF@arrow@display@label{#2}{0}\CF@tmp@str{Uarrow@start}{#1}{1}\CF@tmp@str{Uarrow@end}%
	\fi
}

\pgfdeclarearrow{%
	name = CF,%
	defaults = {%
		length  = 3pt 5 1,%
		width'  = 0pt .8,%
		inset'  = 0pt .5,%
		line width = 0pt 1 1,%
		round%
	},%
	setup code = {%
		% Cap the line width at 1/4th distance from inset to tip
		\pgf@x\pgfarrowlength
		\advance\pgf@x by-\pgfarrowinset
		\pgf@x.25\pgf@x
		\ifdim\pgf@x<\pgfarrowlinewidth\pgfarrowlinewidth\pgf@x\fi
		% Compute front miter length:
		\pgfmathdivide@{\pgf@sys@tonumber\pgfarrowlength}{\pgf@sys@tonumber\pgfarrowwidth}%
		\let\pgf@temp@quot\pgfmathresult%
		\pgf@x\pgfmathresult pt%
		\pgf@x\pgfmathresult\pgf@x%
		\pgf@x4\pgf@x%
		\advance\pgf@x by1pt%
		\pgfmathsqrt@{\pgf@sys@tonumber\pgf@x}%
		\pgf@xc\pgfmathresult\pgfarrowlinewidth% xc is front miter
		\pgf@xc.5\pgf@xc
		\pgf@xa\pgf@temp@quot\pgfarrowlinewidth% xa is extra harpoon miter
		% Compute back miter length:
		\pgf@ya.5\pgfarrowwidth%
		\csname pgfmathatan2@\endcsname{\pgfmath@tonumber\pgfarrowlength}{\pgfmath@tonumber\pgf@ya}%
		\pgf@yb\pgfmathresult pt%
		\csname pgfmathatan2@\endcsname{\pgfmath@tonumber\pgfarrowinset}{\pgfmath@tonumber\pgf@ya}%
		\pgf@ya\pgfmathresult pt%
		\advance\pgf@yb by-\pgf@ya%
		\pgf@yb.5\pgf@yb% half angle in yb
		\pgfmathtan@{\pgf@sys@tonumber\pgf@yb}%
		\pgfmathreciprocal@{\pgfmathresult}%
		\pgf@yc\pgfmathresult\pgfarrowlinewidth%
		\pgf@yc.5\pgf@yc%
		\advance\pgf@ya by\pgf@yb%
		\pgfmathsincos@{\pgf@sys@tonumber\pgf@ya}%
		\pgf@ya\pgfmathresulty\pgf@yc% ya is the back miter
		\pgf@yb\pgfmathresultx\pgf@yc% yb is the top miter
		\ifdim\pgfarrowinset=\z@
			\pgf@ya.5\pgfarrowlinewidth% easy: back miter is half linewidth
		\fi
		% Compute inset miter length:
		\pgfmathdivide@{\pgf@sys@tonumber\pgfarrowinset}{\pgf@sys@tonumber\pgfarrowwidth}%
		\let\pgf@temp@quot\pgfmathresult%
		\pgf@x\pgfmathresult pt%
		\pgf@x\pgfmathresult\pgf@x%
		\pgf@x4\pgf@x%\pgf@ya
		\advance\pgf@x by1pt%
		\pgfmathsqrt@{\pgf@sys@tonumber\pgf@x}%
		\pgf@yc\pgfmathresult\pgfarrowlinewidth% yc is inset miter
		\pgf@yc.5\pgf@yc% 
		% Inner length (pgfutil@tempdima) is now arrowlength - front miter - back miter
		\pgfutil@tempdima\pgfarrowlength%
		\advance\pgfutil@tempdima by-\pgf@xc%
		\advance\pgfutil@tempdima by-\pgf@ya%
		\pgfutil@tempdimb.5\pgfarrowwidth%
		\advance\pgfutil@tempdimb by-\pgf@yb%
		% harpoon miter correction
		\ifpgfarrowroundjoin
			\pgfarrowssetbackend{\pgf@ya\advance\pgf@x by-.5\pgfarrowlinewidth}%
		\else
			\pgfarrowssetbackend{0pt}
		\fi
		\ifpgfarrowharpoon
			\pgfarrowssetlineend{\pgfarrowinset\advance\pgf@x by\pgf@yc\advance\pgf@x by.5\pgfarrowlinewidth}%
		\else
			\pgfarrowssetlineend{\pgfarrowinset\advance\pgf@x by\pgf@yc\advance\pgf@x by-.25\pgfarrowlinewidth}%
			\ifpgfarrowreversed
				\ifdim\pgfinnerlinewidth>0pt
					\pgfarrowssetlineend{\pgfarrowinset}%
				\else
					\pgfarrowssetlineend{\pgfutil@tempdima\advance\pgf@x by\pgf@ya\advance\pgf@x by-.25\pgfarrowlinewidth}%
				\fi
			\fi
		\fi
		\ifpgfarrowroundjoin
			\pgfarrowssettipend{\pgfutil@tempdima\advance\pgf@x by\pgf@ya\advance\pgf@x by.5\pgfarrowlinewidth}%
		\else
			\pgfarrowssettipend{\pgfarrowlength\ifpgfarrowharpoon\advance\pgf@x by\pgf@xa\fi}%
		\fi
		% The hull:
		\pgfarrowshullpoint{\pgfarrowlength\ifpgfarrowroundjoin\else\ifpgfarrowharpoon\advance\pgf@x by\pgf@xa\fi\fi}{\ifpgfarrowharpoon-.5\pgfarrowlinewidth\else0pt\fi}%
		\pgfarrowsupperhullpoint{0pt}{.5\pgfarrowwidth}%
		\pgfarrowshullpoint{\pgfarrowinset}{\ifpgfarrowharpoon-.5\pgfarrowlinewidth\else 0pt\fi}%
		% Adjust inset
		\pgfarrowssetvisualbackend{\pgfarrowinset}%
		\advance\pgfarrowinset by\pgf@yc%
		% The following are needed in the code:
		\pgfarrowssavethe\pgfutil@tempdima
		\pgfarrowssavethe\pgfutil@tempdimb
		\pgfarrowssavethe\pgfarrowlinewidth
		\pgfarrowssavethe\pgf@ya
		\pgfarrowssavethe\pgfarrowinset
	},%
	drawing code = {%
		\pgfsetdash{}{0pt}%
		\ifpgfarrowroundjoin\pgfsetroundjoin\else\pgfsetmiterjoin\fi
		\ifdim\pgfarrowlinewidth=\pgflinewidth\else\pgfsetlinewidth{\pgfarrowlinewidth}\fi
		\pgfpathmoveto{\pgfqpoint{\pgfutil@tempdima\advance\pgf@x by\pgf@ya}{0pt}}%
		\pgfpathlineto{\pgfqpoint{\pgf@ya}{\pgfutil@tempdimb}}%
		\pgfpathlineto{\pgfqpoint{\pgfarrowinset}{0pt}}%
		\ifpgfarrowharpoon \else
			\pgfpathlineto{\pgfqpoint{\pgf@ya}{-\pgfutil@tempdimb}}%
		\fi
		\pgfpathclose
		\ifpgfarrowopen\pgfusepathqstroke\else\ifdim\pgfarrowlinewidth>0pt \pgfusepathqfillstroke\else\pgfusepathqfill\fi\fi
	},%
	parameters = {%
		\the\pgfarrowlinewidth,%
		\the\pgfarrowlength,%
		\the\pgfarrowwidth,%
		\the\pgfarrowinset,%
		\ifpgfarrowharpoon h\fi%
		\ifpgfarrowopen o\fi%
		\ifpgfarrowroundjoin j\fi%
	}%
}

\def\CF@grab@delim#1#2#3\@nil{\def\CF@left@delim{#1}\def\CF@right@delim{#2}}
\def\CF@resetdelim{%
	\setKVdefault[CFdelimiters]
		{delimiters  =(),
		 height      =10pt,
		 depth       =,
		 open xshift =0pt,
		 close xshift=,
		 indice      =n}%
}
\CF@resetdelim
\def\polymerdelim{\CF@ifnextchar[{\polymerdelim@a}{\polymerdelim@a[]}}
\def\polymerdelim@a[#1]#2#3{%
	\CF@resetdelim
	\CF@doifnotempty{#1}{\setKV[CFdelimiters]{#1}}%
	\expandafter\expandafter\expandafter\CF@grab@delim\useKV[CFdelimiters]{delimiters}()\@nil
	\edef\CF@delim@height{\the\dimexpr\useKV[CFdelimiters]{height}}%
	\CF@eexp@macroarg\CF@ifempty{\useKV[CFdelimiters]{depth}}
		{\let\CF@delim@depth\CF@delim@height}
		{\edef\CF@delim@depth{\the\dimexpr\useKV[CFdelimiters]{depth}}}%
	\edef\CF@delim@halfdim{\the\dimexpr(\CF@delim@height+\CF@delim@depth)/2}%
	\edef\CF@delim@vshift {\the\dimexpr(\CF@delim@height-\CF@delim@depth)/2}%
	\edef\CF@leftdelim@xshift{\the\dimexpr\useKV[CFdelimiters]{open xshift}}%
	\CF@eexp@macroarg\CF@ifempty{\useKV[CFdelimiters]{close xshift}}
		{\edef\CF@rightdelim@xshift{\the\dimexpr-\useKV[CFdelimiters]{open xshift}}}
		{\edef\CF@rightdelim@xshift{\the\dimexpr-\useKV[CFdelimiters]{close xshift}}}%
	\chemmove{%
		\nulldelimiterspace0pt
		\pgfextractx\CF@dim{\pgfpointanchor{#2}{center}}\edef\CF@leftdelim@x{\the\CF@dim}%
		\pgfextracty\CF@dim{\pgfpointanchor{#2}{center}}\edef\CF@leftdelim@y{\the\CF@dim}%
		\pgfextractx\CF@dim{\pgfpointanchor{#3}{center}}\edef\CF@rightdelim@x{\the\CF@dim}%
		\node[at={(\CF@leftdelim@x+\CF@leftdelim@xshift,\CF@leftdelim@y+\CF@delim@vshift)}]
			{$\left\CF@left@delim\vrule height\CF@delim@halfdim depth\CF@delim@halfdim width0pt\right.$};%
		\node[at={(\CF@rightdelim@x+\CF@rightdelim@xshift,\CF@leftdelim@y+\CF@delim@vshift)}]
			{$\left.\vrule height\CF@delim@halfdim depth\CF@delim@halfdim width0pt\right\CF@right@delim
				\CF@eexp@macroarg\CF@doifnotempty{\useKV[CFdelimiters]{indice}}
					{_{\rlap{$\scriptstyle\useKV[CFdelimiters]{indice}$}}}
			$};
	}%
}

\CFrestorecatcode
\endinput

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%                       H I S T O R I Q U E                      %%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

v0.1        2010/06/23
    - Première version publique sur le CTAN
----------------------------------------------------------------------
v0.2        2010/08/31
    - Ajout de la documentation en anglais.
    - Correction de bugs.
    - \printatom est désormais une macro publique.
    - Les espaces sont permis dans les molécules. Ils seront
      ignorés par défaut puisque les atomes sont composés en
      mode math par \printatom
    - Une paire de Lewis peut être représentée ":".
    - Dans les cycles, une correction de la longueur du trait
      déporté des liaisons doubles est fait de telle sorte que si
      l'on écrit \chemfig{*5(=====)}, on obtient deux polygones
      réguliers concentriques.
    - La séquence de contrôle \setnodestyle permet de spécifier
      le style des n?uds dessinés par tikz.
----------------------------------------------------------------------
v0.3        2010/11/21
    - Amélioration de \definesubmol qui accepte les séquences de
      contrôle. On peut aussi choisir un alias dont la substitution
      est différente selon l'orientation de la liaison qui lui
      arrive dessus.
    - Le caractère "|" force la fin d'un atome. Si on écrit
      "D|ef" alors, chemfig verra deux atomes "D" et "ef".
    - Le caractère "#" est reconnu lorsqu'il suit un caractère de
      liaison. Il doit être suivi d'un argument entre parenthèses
      qui contient l'offset de début et de fin qui s'appliqueront
      à cette liaison.
    - La macro \chemfig admet un argument optionnel qui sera passé
      à l'environnement tikzpicture dans lequel elle est dessinée
    - Mise en place de la représentation des mécanismes
      réactionnels avec la syntaxe "@{<nom>}" devant un atome où
      "@{<nom>,<coeff>}" au tout début de l'argument d'une liaison.
      Cette syntaxe permet de placer un n?ud (au sens de tikz) qui
      deviendra l'extrémité des flèches des mécanismes.
      Le tracé des flèches est faite par la macro \chemmove dont
      l'argument optionnel devient celui de l'environnement
      tikzpicture dans lequel sont faites les flèches.
    - Pour le mécanisme d'alignement vertical via le \vphantom, la
      commande \chemskipalign permet d'ignorer le groupe d'atomes
      dans lequel elle est écrite.
    - La commande \chemname permet d'afficher un nom sous une
      molécule. la commande \chemnameinit initialise la plus grande
      profondeur rencontrée.
    - La commande \lewis a été modifiée de telle sorte que les
      dessins des décorations soient proportionnels à la taille
      de la police.
----------------------------------------------------------------------
v0.3a       2011/01/08
    - Correction d'un bug dans l'argument optionnel de \definesubmol
      lorsque celui-ci comporte des crochets.
    - Mise à jour du manuel en anglais.
    - Ajout de \vflipnext et \hflipnext pour retourner
      horizontalement ou verticalement la prochaine molécule.
----------------------------------------------------------------------
v0.4        2011/03/07
    - chemfig est désormais écrit en plain-etex et donc
      utilisable par d'autres formats que LaTeX.
    - Un peu plus de rigueur avec les catcodes des caractères
      spéciaux, notamment lorsque la commande \chemfig se trouve
      dans l'argument de \chemmove, \chemabove, \chembelow, \chemrel.
      TODO : faut-il \scantoker l'argument de \chemfig pour être
      définitivement débarrassé de ces histoires de catcode ???
    - Correction d'un bug dans le calcul de l'angle des liaisons
----------------------------------------------------------------------
v0.4a       2011/04/10
    - Correction d'un bug concernant l'argument optionnel en début
      de molécule.
----------------------------------------------------------------------
v0.4b       2011/04/24
    - l'argument de \chemfig est tokénisé avec \scantokens ce qui
      rend caduc tout souci de code de catégorie, à part #.
    - la commande \setbondstyle permet de définir le style des
      liaisons.
    - correction de l'affichage incorrect des doubles liaisons dans
      les cycles après les commandes \hflipnext et \vflipnext
    - correction d'un bug lorsqu'un alias commence une molécule
----------------------------------------------------------------------
v1.0       2011/06/15
    - les schémas réactionnels sont désormais disponibles.
    - \Chemabove et \Chembelow modifient la boite englobante.
    - \Lewis modifie la boite englobante
    - les macros \chemleft, \chemright, \chemup et \chemdown
      affichent des délimiteurs extensibles à gauche, à droite,
      au dessus et au dessous d'un matériel.
----------------------------------------------------------------------
v1.0a      2011/09/18
    - les macros \Lewis et \lewis admettent un argument optionnel
    - la macro \setlewisdist règle la distance entre les 2
      électrons
----------------------------------------------------------------------
v1.0b      2011/11/29
    - la commande \merge est désormais protégée entre
      \schemestart et \schemestop contre des définitions par d'autres
      packages.
    - \box\z@ est utilisé au lieu du maladroit \unhbox\z@
----------------------------------------------------------------------
v1.0c      2011/11/30
    - la macro \+ n'est plus explicitement écrite
    - vérifie que eTeX est le moteur utilisé
----------------------------------------------------------------------
v1.0d      2011/12/19
    - les cercles des cycles étaient tracés au mauvais moment. La
      longueur de la liaison qui les précédait influait sur le
      rayon du cercle : \chemfig{-[,0.5]**6(------)} donnait un bug
      à l'affichage.
----------------------------------------------------------------------
v1.0e      2012/01/13
    - la gestion des espaces dans les groupes d'atomes est
      désormais plus rigoureuse. Plusieurs bugs ont été
      corrigé
----------------------------------------------------------------------
v1.0f      2012/02/24
    - correction d'un bug avec \definesubmol, les catcodes n'étaient
      pas correctement gérés.
----------------------------------------------------------------------
v1.0g      2012/11/16
    - correction d'un bug dans \CF@direct@arrow pour faire prendre en
      compte le style des flèche par défaut
    - correction d'un bug dans \CF@lewis@c : la boite *doit* être
      composée en dehors de l'environnement tikzpicture pour
      éviter nullfont si jamais \printatom ne passe pas en mode
      math.
    - correction d'un bug dans \CF@chemfig@e : si une longueur par
      défaut est modifiée par [,<l>] au début d'une molécule
      et si des cycles étaient emboités, cette longueur n'était
      pas appliquée aux sous-cycles.
    - ré-écriture des macros \chemabove et \chembemow pour
      prendre en compte le bug (désormais corrigé) dans luatex.
    - nouvelle macro \setstacksep qui définit l'espacement par
      défaut dans les macros \chemabove et \chembelow.
----------------------------------------------------------------------
v1.0h      2013/11/28
    - \chemname admet maintenant une version étoilé qui ne tient
      pas compte des profondeurs précédentes.
    - \CF@dp@max est géré globalement.
    - correction d'un bug dans "-U>" : le style de la flèche
      n'était pris en compte pour l'arc.
    - correction d'un bug dans \CF@direct@arrow : l'angle de la
      flèche n'était pas calculé
----------------------------------------------------------------------
v1.1       2015/02/13
    - correction d'un bug dans \CF@seek@submol : la macro
      \CF@remain@molecule est dépouillé de son éventuel espace
      en première position.
    - correction d'un bug dans \CF@arrow@f : le nom du prochain
      n?ud courant "end@arrow@i" était erroné dans le cas où une
      flèche contenait un sous schéma. Ce nom doit dépendre de
      \CF@scheme@nest.
    - la jonction entre deux liaisons consécutives dans l'axe peut
      être activé avec \enablebondjoin et désactivé avec
      \disablebondjoin (préférable, état par défaut).
    - \chemfig suivi d'une "*" demande à ce que les liaisons aient
      une longueur invariable : la distance inter-atome devient donc
      variable. Cette fonctionnalité est désactivé dans les
      cycles afin que les polygones soient réguliers.
      \enablefixedbondlength permet cette fonctionnalité pour
      toutes les macros \chemfig (même non étoilée) tandis que
      \disablefixedbondlength le désactive.
----------------------------------------------------------------------
v1.1a      2015/02/23
    - correction d'un bug dans \CF@grab@bondoffset. Si \chemfig est
      dans l'argument d'une macro, les # sont doublés par l'action
      de \scantokens de la macro \CF@chemfig@d et il faut un
      argument délimité avant "(" pour absorber tous les #.
----------------------------------------------------------------------
v1.2       2015/10/08
    - correction d'un bug dans le tracé des liaisons de Cram.
    - création de \setangleincrement.
    - chargement de "arrows.meta" et définition de la flèche "CF"
      basée sur "Stealth" et définie avec \pgfdeclarearrow.
      Les anciennes flèches "CF@full" et "CF@half" sont
      abandonnées puisque définies avec \pgfarrowsdeclare.
    - flèche "-U>" corrigée : le placement des labels est
      maintenant correct dans tous les cas. Ainsi :
                         -U>[<a>][<b>][<d>][r][a]
      place le label <a> près du début de la flèche, quels que
      soient les signes du rayon r et de l'angle a.
    - \chemrel, \setchemrel et \chemsign sont supprimées.
    - compatibilité, avec les limitations d'usage, avec la
      librairie "externalize" : le \begin{tikzpicture} voit
      désormais le \end{tikzpicture} correspondant dans la macro
      \CF@chemfig@d.
----------------------------------------------------------------------
v1.2a      2015/10/21
    - erreur de copier-coller dans le code: une adresse url était
      malencontreusement présente en plein milieu d'une ligne de
      code
----------------------------------------------------------------------
v1.2b      2015/11/15
    - bug dans \CF@seek@submol qui laissait "*" dans le flux de
      lecture de TeX. Un message d'erreur est également ajouté
      en cas de "!" en fin de traitement.
    - correction d'un bug dans \CF@set@bondangle où l'angle [<:a>]
      n'était pas évalué par \pgfmathsetmacro.
----------------------------------------------------------------------
v1.2c      2015/11/20
    - Correction d'un bug dans \CF@set@bondangle : l'angle renvoyé
      pouvait être négatif
    - Correction d'un bug dans \CF@direct@arrow : la macro \CF@ifempty
      n'est pas correctement développée dans l'argument de
      \pgfpointanchor
----------------------------------------------------------------------
v1.2d      2015/12/01
    - correction d'un bug dans la flèche "-U"
    - la version étoilée de \setcrambond dessine les liaisons de
      Cram en pointillés sous forme de trait large et non pas sous
      forme de triangle.
----------------------------------------------------------------------
v1.2e      2017/05/20
    - la macro contenant la définition d'une flèche est
      désormais "\CF@arrow(<nom>)", ainsi la macro \0 n'est plus
      définie par \definearrow
    - remerciements rajoutés après une suppression indue, pour ne
      froisser aucune susceptibilité
----------------------------------------------------------------------
v1.3       2018/03/08
    - tous les paramètres sont désormais passés via \setchemfig qui
      fait appel à "simplekv". Par conséquent, _toutes_ les macros qui
      réglaient des paramètres deviennent obsolètes, à savoir :
          \setcrambond, \setatomsep, \setbondoffset, \setdoublesep,
          \setangleincrement, \enablefixedbondlength,
          \disablefixedbondlength, \setnodestyle, \setbondstyle,
          \setlewis, \setlewisdist, \setstacksep, \setcompoundstyle,
          \setarrowdefault, \setandsign, \setarrowoffset,
          \setcompoundsep, \setarrowlabelsep, \enablebondjoin,
          \disablebondjoin et \schemedebug.
      et ces macros seront *supprimées* dans une future version.
    - la version étoilée "\chemfig*" et les deux arguments optionnels
      de la macro "\chemfig[][]" sont également optionnels et seront
      *supprimé*s dans une future version afin d'accéder à la syntaxe
      \chemfig[clés=valeurs]{code}
    - 6 nouveaux paramètres : "lewis radius", "arrow double sep",
      "arrow double coeff", "arrow double harpoon", "cycle radius
      coeff", "arrow head".
    - correction d'un bug dans \CF@parse@mergeopt qui dans certains
      cas, envoyait vers l'affichage des caractères
    - petit toilettage du code
    - macro \polymerdelim (non documentée) expérimentale et encore
      en phase de tests
    - suppression d'un registre d'écriture de fichier
    ----------------------------------------------------------------------
v1.31       2018/04/05
    - correction d'un espace indésirable dans \CF@ifnextchar
    ----------------------------------------------------------------------
v1.32       2018/08/23
    - définition de \printatom, \CF@begin@tikzpicture et 
      \CF@end@tikzpicture dans le fichier t-chemfig.tex
          ----------------------------------------------------------------------
v1.33       2018/10/31
    - les macros définies par \definesubmol peuvent désormais avoir un ou
      plusieurs arguments
    - macro \polymerdelim documentée